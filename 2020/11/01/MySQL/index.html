<!DOCTYPE html>
<html lang="zh-CN,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zystrivego.github.io","root":"/","scheme":"Pisces","version":"8.0.0-rc.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="mysql学习总结">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="https://zystrivego.github.io/2020/11/01/MySQL/index.html">
<meta property="og:site_name" content="zystrivego">
<meta property="og:description" content="mysql学习总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table1.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table2.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table3.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table4.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table5.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table6.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table7.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table8.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table9.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table10.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table11.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table12.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table13.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table14.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table15.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table16.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table17.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table18.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table19.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table20.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table21.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table22.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table23.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table24.jpg">
<meta property="og:image" content="https://zystrivego.github.io/2020/11/01/MySQL/table25.jpg">
<meta property="article:published_time" content="2020-11-01T15:58:07.000Z">
<meta property="article:modified_time" content="2022-08-07T04:03:34.397Z">
<meta property="article:author" content="zhangyu">
<meta property="article:tag" content="sql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zystrivego.github.io/2020/11/01/MySQL/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.jpg">

<link rel="canonical" href="https://zystrivego.github.io/2020/11/01/MySQL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL | zystrivego</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-166280277-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-166280277-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d80a08decb023081a8512483b9302992";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="zystrivego" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zystrivego</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zystrivego.github.io/2020/11/01/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E7%8E%8B%E4%B9%9F.jpg">
      <meta itemprop="name" content="zhangyu">
      <meta itemprop="description" content="The world is your oyster">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zystrivego">
    </span>
      <header class="post-header">
        
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-01 23:58:07" itemprop="dateCreated datePublished" datetime="2020-11-01T23:58:07+08:00">2020-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-07 12:03:34" itemprop="dateModified" datetime="2022-08-07T12:03:34+08:00">2022-08-07</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/11/01/MySQL/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/11/01/MySQL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>mysql学习总结</p>
</blockquote>
<a id="more"></a>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><img src="/2020/11/01/MySQL/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.jpg" class="">



<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。</p>
<blockquote>
<p>假如A转账给B 100 元，先从A的账户里扣除 100 元，再在 B 的账户上加上 100 元。如果扣完A的100元后，还没来得及给B加上，银行系统异常了，最后导致A的余额减少了，B的余额却没有增加。所以就需要事务，将A的钱回滚回去，就是这么简单。</p>
</blockquote>
<h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><img src="/2020/11/01/MySQL/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7.jpg" class="">



<ul>
<li><strong>原子性：</strong> 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部都执行，要么都不执行。</li>
<li><strong>一致性：</strong> 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。</li>
<li><strong>隔离性：</strong> 多个事务并发访问时，事务之间是相互隔离的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。。</li>
<li><strong>持久性：</strong> 表示事务完成提交后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li>
</ul>
<h2 id="事务并发存在的问题"><a href="#事务并发存在的问题" class="headerlink" title="事务并发存在的问题"></a>事务并发存在的问题</h2><p>事务并发执行存在什么问题呢，换句话说就是，一个事务是怎么干扰到其他事务的呢？看例子吧~</p>
<p>假设现在有表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;name&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;balance&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;un_name_idx&#96; (&#96;name&#96;) USING BTREE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<p>表中有数据：</p>
<img src="/2020/11/01/MySQL/table1.jpg" class="">



<h3 id="脏读（dirty-read）"><a href="#脏读（dirty-read）" class="headerlink" title="脏读（dirty read）"></a>脏读（dirty read）</h3><p>假设现在有两个事务A、B：</p>
<ul>
<li>假设现在A的余额是100，事务A正在准备查询Jay的余额</li>
<li>这时候，事务B先扣减Jay的余额，扣了10</li>
<li>最后A 读到的是扣减后的余额</li>
</ul>
<img src="/2020/11/01/MySQL/table2.jpg" class="">



<p>由上图可以发现，事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是<strong>脏读</strong>。</p>
<h3 id="不可重复读（unrepeatable-read）"><a href="#不可重复读（unrepeatable-read）" class="headerlink" title="不可重复读（unrepeatable read）"></a>不可重复读（unrepeatable read）</h3><p>假设现在有两个事务A和B：</p>
<ul>
<li>事务A先查询Jay的余额，查到结果是100</li>
<li>这时候事务B 对Jay的账户余额进行扣减，扣去10后，提交事务</li>
<li>事务A再去查询Jay的账户余额发现变成了90</li>
</ul>
<img src="/2020/11/01/MySQL/table3.jpg" class="">



<p>事务A又被事务B干扰到了！在事务A范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是<strong>不可重复读</strong>。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>假设现在有两个事务A、B：</p>
<ul>
<li>事务A先查询id大于2的账户记录，得到记录id=2和id=3的两条记录</li>
<li>这时候，事务B开启，插入一条id=4的记录，并且提交了</li>
<li>事务A再去执行相同的查询，却得到了id=2,3,4的3条记录了。</li>
</ul>
<img src="/2020/11/01/MySQL/table4.jpg" class="">



<p>事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是<strong>幻读</strong>。</p>
<h2 id="事务的四大隔离级别实践"><a href="#事务的四大隔离级别实践" class="headerlink" title="事务的四大隔离级别实践"></a>事务的四大隔离级别实践</h2><p>既然并发事务存在<strong>脏读、不可重复、幻读</strong>等问题，InnoDB实现了哪几种事务的隔离级别应对呢？</p>
<ul>
<li>读未提交（Read Uncommitted）</li>
<li>读已提交（Read Committed）</li>
<li>可重复读（Repeatable Read）</li>
<li>串行化（Serializable）</li>
</ul>
<h3 id="读未提交（Read-Uncommitted）"><a href="#读未提交（Read-Uncommitted）" class="headerlink" title="读未提交（Read Uncommitted）"></a>读未提交（Read Uncommitted）</h3><p>想学习一个知识点，最好的方式就是实践之。好了，我们去数据库给它设置<strong>读未提交</strong>隔离级别，实践一下吧~</p>
<img src="/2020/11/01/MySQL/table5.jpg" class="">



<p>先把事务隔离级别设置为read uncommitted，开启事务A，查询id=1的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br><span class="line">begin;</span><br><span class="line">select * from account where id &#x3D;1;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<img src="/2020/11/01/MySQL/table6.jpg" class="">

<p>这时候，另开一个窗口打开mysql，也把当前事务隔离级别设置为read uncommitted，开启事务B，执行更新操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br><span class="line">begin;</span><br><span class="line">update account set balance&#x3D;balance+20 where id &#x3D;1;</span><br></pre></td></tr></table></figure>

<p>接着回事务A的窗口，再查account表id=1的数据，结果如下：</p>
<img src="/2020/11/01/MySQL/table7.jpg" class="">



<p>可以发现，在<strong>读未提交（Read Uncommitted）</strong> 隔离级别下，一个事务会读到其他事务未提交的数据的，即存在<strong>脏读</strong>问题。事务B都还没commit到数据库呢，事务A就读到了，感觉都乱套了。。。实际上，读未提交是隔离级别最低的一种。</p>
<h3 id="已提交读（READ-COMMITTED）"><a href="#已提交读（READ-COMMITTED）" class="headerlink" title="已提交读（READ COMMITTED）"></a>已提交读（READ COMMITTED）</h3><p>为了避免脏读，数据库有了比<strong>读未提交</strong>更高的隔离级别，即<strong>已提交读</strong>。</p>
<img src="/2020/11/01/MySQL/table8.jpg" class="">



<p>把当前事务隔离级别设置为已提交读（READ COMMITTED），开启事务A，查询account中id=1的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed;</span><br><span class="line">begin;</span><br><span class="line">select * from account where id &#x3D;1;</span><br></pre></td></tr></table></figure>

<p>另开一个窗口打开mysql，也把事务隔离级别设置为read committed，开启事务B，执行以下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed;</span><br><span class="line">begin;</span><br><span class="line">update account set balance&#x3D;balance+20 where id &#x3D;1;</span><br></pre></td></tr></table></figure>

<p>接着回事务A的窗口，再查account数据，发现数据没变：</p>
<img src="/2020/11/01/MySQL/table9.jpg" class="">



<p>我们再去到事务B的窗口执行commit操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>最后回到事务A窗口查询，发现数据变了：</p>
<img src="/2020/11/01/MySQL/table10.jpg" class="">



<p>由此可以得出结论，隔离级别设置为<strong>已提交读（READ COMMITTED）</strong> 时，已经不会出现脏读问题了，当前事务只能读取到其他事务提交的数据。但是，你站在事务A的角度想想，存在其他问题吗？</p>
<p><strong>提交读的隔离级别会有什么问题呢？</strong></p>
<p>在同一个事务A里，相同的查询sql，读取同一条记录（id=1），读到的结果是不一样的，即<strong>不可重复读</strong>。所以，隔离级别设置为read committed的时候，还会存在<strong>不可重复读</strong>的并发问题。</p>
<h3 id="可重复读（Repeatable-Read）"><a href="#可重复读（Repeatable-Read）" class="headerlink" title="可重复读（Repeatable Read）"></a>可重复读（Repeatable Read）</h3><p>如果你的老板要求，在同个事务中，查询结果必须是一致的，即老板要求你解决不可重复的并发问题，怎么办呢？老板，臣妾办不到？来实践一下<strong>可重复读（Repeatable Read）</strong> 这个隔离级别吧~</p>
<img src="/2020/11/01/MySQL/table11.jpg" class="">



<p>哈哈，步骤1、2、6的查询结果都是一样的，即<strong>repeatable read解决了不可重复读问题</strong>，是不是心里美滋滋的呢，终于解决老板的难题了~</p>
<p><strong>RR级别是否解决了幻读问题呢？</strong></p>
<p>再来看看网上的一个热点问题，有关于RR级别下，是否解决了幻读问题？我们来实践一下：</p>
<img src="/2020/11/01/MySQL/table12.jpg" class="">

<p>由图可得，步骤2和步骤6查询结果集没有变化，看起来RR级别是已经解决幻读问题了~ 但是呢，<strong>RR级别还是存在这种现象</strong>：</p>
<img src="/2020/11/01/MySQL/table13.jpg" class="">



<p>其实，上图如果事务A中，没有<code>update account set balance=200 where id=5;</code>这步操作，<code>select * from account where id&gt;2</code>查询到的结果集确实是不变，这种情况没有<strong>幻读</strong>问题。但是，有了update这个骚操作，同一个事务，相同的sql，查出的结果集不同，这个是符合了<strong>幻读</strong>的定义~</p>
<p>这个问题，亲爱的朋友，你觉得它算幻读问题吗？</p>
<h3 id="串行化（Serializable）"><a href="#串行化（Serializable）" class="headerlink" title="串行化（Serializable）"></a>串行化（Serializable）</h3><p>前面三种数据库隔离级别，都有一定的并发问题，现在放大招吧，实践SERIALIZABLE隔离级别。</p>
<p>把事务隔离级别设置为Serializable，开启事务A，查询account表数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">select * from account;</span><br></pre></td></tr></table></figure>

<p>另开一个窗口打开mysql，也把事务隔离级别设置为Serializable，开启事务B，执行插入一条数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">insert into account(id,name,balance) value(6,&#39;Li&#39;,100);</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<img src="/2020/11/01/MySQL/table14.jpg" class="">



<p>由图可得，当数据库隔离级别设置为serializable的时候，事务B对表的写操作，在等事务A的读操作。其实，这是隔离级别中最严格的，读写都不允许并发。它保证了最好的安全性，性能却是个问题~</p>
<h2 id="MySql隔离级别的实现原理"><a href="#MySql隔离级别的实现原理" class="headerlink" title="MySql隔离级别的实现原理"></a>MySql隔离级别的实现原理</h2><p>实现隔离机制的方法主要有两种：</p>
<ul>
<li>读写锁</li>
<li>一致性快照读，即 MVCC</li>
</ul>
<p>MySql使用不同的锁策略(Locking Strategy)/MVCC来实现四种不同的隔离级别。RR、RC的实现原理跟MVCC有关，RU和Serializable跟锁有关。</p>
<h3 id="读未提交（Read-Uncommitted）-1"><a href="#读未提交（Read-Uncommitted）-1" class="headerlink" title="读未提交（Read Uncommitted）"></a>读未提交（Read Uncommitted）</h3><p><strong>官方说法：</strong></p>
<blockquote>
<p>SELECT statements are performed in a nonlocking fashion, but a possible earlier version of a row might be used. Thus, using this isolation level, such reads are not consistent.</p>
</blockquote>
<p>读未提交，采取的是读不加锁原理。</p>
<ul>
<li>事务读不加锁，不阻塞其他事务的读和写</li>
<li>事务写阻塞其他事务写，但不阻塞其他事务读；</li>
</ul>
<h3 id="串行化（Serializable"><a href="#串行化（Serializable" class="headerlink" title="串行化（Serializable)"></a>串行化（Serializable)</h3><p><strong>官方的说法:</strong></p>
<blockquote>
<p>InnoDB implicitly converts all plain SELECT statements to SELECT … FOR SHARE if autocommit is disabled. If autocommit is enabled, the SELECT is its own transaction. It therefore is known to be read only and can be serialized if performed as a consistent (nonlocking) read and need not block for other transactions. (To force a plain SELECT to block if other transactions have modified the selected rows, disable autocommit.)</p>
</blockquote>
<ul>
<li>所有SELECT语句会隐式转化为<code>SELECT ... FOR SHARE</code>，即加共享锁。</li>
<li>读加共享锁，写加排他锁，读写互斥。如果有未提交的事务正在修改某些行，所有select这些行的语句都会阻塞。</li>
</ul>
<h3 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h3><p>MVCC，中文叫<strong>多版本并发控制</strong>，它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。它的实现依赖于<strong>隐式字段、undo日志、快照读&amp;当前读、Read View</strong>，因此，我们先来了解这几个知识点。</p>
<h4 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h4><p>对于InnoDB存储引擎，每一行记录都有两个隐藏列<strong>DB_TRX_ID、DB_ROLL_PTR</strong>，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列<strong>DB_ROW_ID</strong>。</p>
<ul>
<li>DB_TRX_ID，记录每一行最近一次修改（修改/更新）它的事务ID，大小为6字节；</li>
<li>DB_ROLL_PTR，这个隐藏列就相当于一个指针，指向回滚段的undo日志，大小为7字节；</li>
<li>DB_ROW_ID，单调递增的行ID，大小为6字节；</li>
</ul>
<img src="/2020/11/01/MySQL/table15.jpg" class="">



<h4 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h4><blockquote>
<ul>
<li>事务未提交的时候，修改数据的镜像（修改前的旧版本），存到undo日志里。以便事务回滚时，恢复旧版本数据，撤销未提交事务数据对数据库的影响。</li>
<li>undo日志是逻辑日志。可以这样认为，当delete一条记录时，undo log中会记录一条对应的insert记录，当update一条记录时，它记录一条对应相反的update记录。</li>
<li>存储undo日志的地方，就是<strong>回滚段</strong>。</li>
</ul>
</blockquote>
<p>多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（DB_ROLL_PTR）连一条<strong>Undo日志链</strong>。</p>
<p>我们通过例子来看一下~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from account ;</span><br><span class="line">+----+------+---------+</span><br><span class="line">| id | name | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | Jay  |     100 |</span><br><span class="line">+----+------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>假设表accout现在只有一条记录，插入该该记录的事务Id为100</li>
<li>如果事务B（事务Id为200），对id=1的该行记录进行更新，把balance值修改为90</li>
</ul>
<p>事务B修改后，形成的<strong>Undo Log链</strong>如下：</p>
<img src="/2020/11/01/MySQL/table16.jpg" class="">



<h4 id="快照读-amp-当前读"><a href="#快照读-amp-当前读" class="headerlink" title="快照读&amp;当前读"></a>快照读&amp;当前读</h4><p><strong>快照读：</strong></p>
<p>读取的是记录数据的可见版本（有旧的版本），不加锁,普通的select语句都是快照读,如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from account where id&gt;2;</span><br></pre></td></tr></table></figure>

<p><strong>当前读：</strong></p>
<p>读取的是记录数据的最新版本，显示加锁的都是当前读</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from account where id&gt;2 lock in share mode; -- 加的是共享锁</span><br><span class="line">select * from  account where id&gt;2 for update; -- 加的是排他锁</span><br></pre></td></tr></table></figure>

<h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><ul>
<li>Read View就是事务执行<strong>快照读</strong>时，产生的读视图。</li>
<li>事务执行快照读时，会生成数据库系统当前的一个快照，记录当前系统中还有哪些活跃的读写事务，把它们放到一个列表里。</li>
<li>Read View主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据~</li>
</ul>
<p>为了下面方便讨论Read View可见性规则，先定义几个变量</p>
<blockquote>
<ul>
<li>m_ids:当前系统中那些活跃的读写事务ID,它数据结构为一个List。</li>
<li>min_limit_id:m_ids事务列表中，最小的事务ID</li>
<li>max_limit_id:m_ids事务列表中，最大的事务ID</li>
</ul>
</blockquote>
<ul>
<li>如果DB_TRX_ID &lt; min_limit_id，表明生成该版本的事务在生成ReadView前已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li>
<li>如果DB_TRX_ID &gt; m_ids列表中最大的事务id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li>
<li>如果 min_limit_id =&lt;DB_TRX_ID&lt;= max_limit_id,需要判断m_ids.contains(DB_TRX_ID)，如果在，则代表Read View生成时刻，这个事务还在活跃，还没有Commit，你修改的数据，当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，修改的结果，当前事务是能看见的。</li>
</ul>
<p><strong>注意啦！！</strong> RR跟RC隔离级别，最大的区别就是：<strong>RC每次读取数据前都生成一个ReadView，而RR只在第一次读取数据时生成一个ReadView</strong>。</p>
<h3 id="已提交读（READ-COMMITTED）-存在不可重复读问题的分析历程"><a href="#已提交读（READ-COMMITTED）-存在不可重复读问题的分析历程" class="headerlink" title="已提交读（READ COMMITTED） 存在不可重复读问题的分析历程"></a>已提交读（READ COMMITTED） 存在不可重复读问题的分析历程</h3><p>我觉得理解一个新的知识点，最好的方法就是<strong>居于目前存在的问题/现象，去分析它</strong>的来龙去脉~ RC的实现也跟MVCC有关，RC是存在重复读并发问题的，所以我们来分析一波RC吧，先看一下执行流程</p>
<img src="/2020/11/01/MySQL/table17.jpg" class="">
<p>假设现在系统里有A，B两个事务在执行，事务ID分别为100、200，并且假设存在的老数据，插入事务ID是50哈~</p>
<p><strong>事务A 先执行查询1的操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 事务A，Transaction ID 100</span><br><span class="line">begin ;</span><br><span class="line">查询1：select *  from account WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p><strong>事务 B 执行更新操作，id =1记录的undo日志链如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update account set balance &#x3D;balance+20 where id &#x3D;1;</span><br></pre></td></tr></table></figure>



<img src="/2020/11/01/MySQL/table18.jpg" class="">

<p><strong>回到事务A，执行查询2的操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin ;</span><br><span class="line">查询1：select *  from account WHERE id &#x3D; 1; </span><br><span class="line">查询2：select *  from account WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p><strong>查询2执行分析：</strong></p>
<ul>
<li>事务A在执行到SELECT语句时，重新生成一个ReadView，因为事务B（200）在活跃，所以ReadView的m_ids列表内容就是[200]</li>
<li>由上图undo日志链可得，最新版本的balance为100，它的事务ID为200，在活跃事务列表里，所以当前事务（事务A）不可见。</li>
<li>我们继续找下一个版本，balance为100这行记录，事务Id为50，小于活跃事务ID列表最小记录200，所以这个版本可见，因此，查询2的结果，就是返回balance=100这个记录~~</li>
</ul>
<p><strong>我们回到事务B，执行提交操作，这时候undo日志链不变</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update account set balance &#x3D;balance+20 where id &#x3D;1;</span><br><span class="line">commit</span><br></pre></td></tr></table></figure>



<img src="/2020/11/01/MySQL/table19.jpg" class="">



<p><strong>再次回到事务A，执行查询3的操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin ;</span><br><span class="line">查询1：select *  from account WHERE id &#x3D; 1; </span><br><span class="line">查询2：select *  from account WHERE id &#x3D; 1; </span><br><span class="line">查询3：select *  from account WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p><strong>查询3执行分析：</strong></p>
<ul>
<li>事务A在执行到SELECT语句时，重新生成一个ReadView，因为事务B（200）已经提交，不载活跃，所以ReadView的m_ids列表内容就是空的了。</li>
<li>所以事务A直接读取最新纪录，读取到balance =120这个版本的数据。</li>
</ul>
<p>所以，这就是RC存在不可重复读问题的过程啦</p>
<h3 id="可重复读（Repeatable-Read）解决不可重复读问题的一次分析"><a href="#可重复读（Repeatable-Read）解决不可重复读问题的一次分析" class="headerlink" title="可重复读（Repeatable Read）解决不可重复读问题的一次分析"></a>可重复读（Repeatable Read）解决不可重复读问题的一次分析</h3><p>我们再来分析一波，RR隔离级别是如何解决不可重复读并发问题的吧~</p>
<p>你可能会觉得两个并发事务的例子太简单了，好的！我们现在来点刺激的，开启三个事务~</p>
<img src="/2020/11/01/MySQL/table20.jpg" class="">

<p>假设现在系统里有A，B，C两个事务在执行，事务ID分别为100、200，300，存量数据插入的事务ID是50~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 事务A，Transaction ID 100</span><br><span class="line">begin ;</span><br><span class="line">UPDATE account SET balance &#x3D; 1000  WHERE id &#x3D; 1;</span><br><span class="line"># 事务B，Transaction ID 200</span><br><span class="line">begin ; &#x2F;&#x2F;开个事务，占坑先</span><br></pre></td></tr></table></figure>

<p><strong>这时候，account表中，id =1记录的undo日志链如下：</strong></p>
<img src="/2020/11/01/MySQL/table21.jpg" class="">



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 事务C，Transaction ID 300</span><br><span class="line">begin ;</span><br><span class="line">&#x2F;&#x2F;查询1：select * from  account WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p><strong>查询1执行过程分析：</strong></p>
<ul>
<li>事务C在执行SELECT语句时，会先生成一个ReadView。因为事务A（100）、B（200）在活跃，所以ReadView的m_ids列表内容就是[100, 200]。</li>
<li>由上图undo日志链可得，最新版本的balance为1000，它的事务ID为100，在活跃事务列表里，所以当前事务（事务C）不可见。</li>
<li>我们继续找下一个版本，balance为100这行记录，事务Id为50，小于活跃事务ID列表最小记录100，所以这个版本可见，因此，查询1的结果，就是返回balance=100这个记录~~</li>
</ul>
<p><strong>接着，我们把事务A提交一下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 事务A，Transaction ID 100</span><br><span class="line">begin ;</span><br><span class="line">UPDATE account SET balance &#x3D; 1000  WHERE id &#x3D; 1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p><strong>在事务B中，执行更新操作，把id=1的记录balance修改为2000，更新完后，undo 日志链如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 事务B，Transaction ID 200</span><br><span class="line">begin ; &#x2F;&#x2F;开个事务，占坑先</span><br><span class="line">UPDATE account SET balance &#x3D; 2000  WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure>



<img src="/2020/11/01/MySQL/table22.jpg" class="">



<p><strong>回到事务C，执行查询2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 事务C，Transaction ID 300</span><br><span class="line">begin ;</span><br><span class="line">&#x2F;&#x2F;查询1：select * from  account WHERE id &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;查询2：select * from  account WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p><strong>查询2:执行分析：</strong></p>
<ul>
<li>在RR 级别下，执行查询2的时候，因为<strong>前面ReadView已经生成过了，所以直接服用之前的ReadView</strong>，活跃事务列表为[100,200].</li>
<li>由上图undo日志链可得，最新版本的balance为2000，它的事务ID为200，在活跃事务列表里，所以当前事务（事务C）不可见。</li>
<li>我们继续找下一个版本，balance为1000这行记录，事务Id为100,也在活跃事务列表里，所以当前事务（事务C）不可见。</li>
<li>继续找下一个版本，balance为100这行记录，事务Id为50，小于活跃事务ID列表最小记录100，所以这个版本可见，因此，查询2的结果，也是返回balance=100这个记录~~</li>
</ul>
<h3 id="锁相关概念补充（附）："><a href="#锁相关概念补充（附）：" class="headerlink" title="锁相关概念补充（附）："></a>锁相关概念补充（附）：</h3><h4 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h4><p>InnoDB 实现了标准的行级锁，包括两种：共享锁（简称 s 锁）、排它锁（简称 x 锁）。</p>
<ul>
<li>共享锁（S锁）：允许持锁事务读取一行。</li>
<li>排他锁（X锁）：允许持锁事务更新或者删除一行。</li>
</ul>
<p>如果事务 T1 持有行 r 的 s 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理：</p>
<ul>
<li>T2 请求 s 锁立即被允许，结果 T1 T2 都持有 r 行的 s 锁</li>
<li>T2 请求 x 锁不能被立即允许</li>
</ul>
<p>如果 T1 持有 r 的 x 锁，那么 T2 请求 r 的 x、s 锁都不能被立即允许，T2 必须等待T1释放 x 锁才可以，因为X锁与任何的锁都不兼容。</p>
<h4 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h4><ul>
<li>记录锁是最简单的行锁，<strong>仅仅锁住一行</strong>。如：<code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE</code></li>
<li>记录锁<strong>永远都是加在索引上</strong>的，即使一个表没有索引，InnoDB也会隐式的创建一个索引，并使用这个索引实施记录锁。</li>
<li>会阻塞其他事务对其插入、更新、删除</li>
</ul>
<p>记录锁的事务数据（关键词：<code>lock_mode X locks rec but not gap</code>），记录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index &#96;PRIMARY&#96; of table &#96;test&#96;.&#96;t&#96; </span><br><span class="line">trx id 10078 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#39;O;;</span><br><span class="line"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>

<h4 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h4><ul>
<li>间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。</li>
<li>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</li>
<li>间隙锁只阻止其他事务插入到间隙中，他们不阻止其他事务在同一个间隙上获得间隙锁，所以 gap x lock 和 gap s lock 有相同的作用。</li>
</ul>
<h4 id="Next-Key-Locks（临键锁）"><a href="#Next-Key-Locks（临键锁）" class="headerlink" title="Next-Key Locks（临键锁）"></a>Next-Key Locks（临键锁）</h4><p>默认情况下，在<strong>RC</strong>级别中使用。在这种情况下，使用Next-Key Locks进行搜索和索引扫描，从而防止幻读。</p>
<ul>
<li>Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。</li>
</ul>
<h3 id="RC级别存在幻读分析"><a href="#RC级别存在幻读分析" class="headerlink" title="RC级别存在幻读分析"></a>RC级别存在幻读分析</h3><p>因为RC是存在幻读问题的，所以我们先切到RC隔离级别，分析一波~</p>
<p>假设account表有4条数据。</p>
<ul>
<li>开启事务A，执行当前读，查询id&gt;2的所有记录。</li>
<li>再开启事务B，插入id=5的一条数据。</li>
<li>事务B插入数据成功后，再修改id=3的记录</li>
<li>回到事务A,再次执行id&gt;2的当前读查询</li>
</ul>
<img src="/2020/11/01/MySQL/table23.jpg" class="">



<ul>
<li>事务B可以插入id=5的数据，却更新不了id=3的数据，陷入阻塞。证明事务A在执行当前读的时候在id =3和id=4这两条记录上加了锁，但是并没有对 id &gt; 2 这个范围加锁~</li>
<li>事务B陷入阻塞后，切回事务A执行当前读操作时，死锁出现。因为事务B在 insert 的时候，会在新纪录（id=5）上加锁，所以事务A再次执行当前读，想获取id&gt; 2 的记录，就需要在 id=3,4,5 这3条记录上加锁，但是 id = 5这条记录已经被事务B 锁住了，于是事务A被事务B阻塞，同时事务B还在等待 事务A释放 id = 3上的锁，最终产生了死锁。</li>
</ul>
<img src="/2020/11/01/MySQL/table24.jpg" class="">



<p>因此，我们可以发现，RC隔离级别下，加锁的select, update, delete等语句，使用的是记录锁，其他事务的插入依然可以执行，因此会存在幻读</p>
<h3 id="RR-级别解决幻读分析"><a href="#RR-级别解决幻读分析" class="headerlink" title="RR 级别解决幻读分析"></a>RR 级别解决幻读分析</h3><p>因为RR是解决幻读问题的，怎么解决的呢，分析一波吧~</p>
<p>假设account表有4条数据，RR级别。</p>
<ul>
<li><p>开启事务A，执行当前读，查询id&gt;2的所有记录</p>
</li>
<li><p>再开启事务B，插入id=5的一条数据。</p>
<img src="/2020/11/01/MySQL/table25.jpg" class="">

<p>可以发现，事务B执行插入操作时，阻塞了~因为事务A在执行select … lock in share mode的时候，不仅在 id = 3,4 这2条记录上加了锁，而且在id &gt; 2 这个范围上也加了间隙锁。</p>
</li>
</ul>
<p>因此，我们可以发现，RR隔离级别下，加锁的select, update, delete等语句，会使用间隙锁+ 临键锁，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻读。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="docker-中下载-mysql"><a href="#docker-中下载-mysql" class="headerlink" title="docker 中下载 mysql"></a>docker 中下载 mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name docker-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;471025 mysql</span><br></pre></td></tr></table></figure>

<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it docker-mysql bash</span><br></pre></td></tr></table></figure>

<h2 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p471025</span><br></pre></td></tr></table></figure>

<h2 id="添加远程登录用户"><a href="#添加远程登录用户" class="headerlink" title="添加远程登录用户"></a>添加远程登录用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;471025&#39;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;</span><br></pre></td></tr></table></figure>

<p>远程连接不上docker中的mysql解决办法<br><a href="https://blog.csdn.net/qq_37924905/article/details/108560767" target="_blank" rel="noopener">https://blog.csdn.net/qq_37924905/article/details/108560767</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/sql/" rel="tag"><i class="fa fa-tag"></i> sql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/20/%E7%90%86%E8%A7%A3RESTful%E6%9E%B6%E6%9E%84/" rel="prev" title="理解RESTful架构">
      <i class="fa fa-chevron-left"></i> 理解RESTful架构
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/09/algorithm/" rel="next" title="algorithm">
      algorithm <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#事务"><span class="nav-number">1.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简述"><span class="nav-number">1.1.</span> <span class="nav-text">简述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是事务？"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是事务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务的四大特性"><span class="nav-number">1.1.2.</span> <span class="nav-text">事务的四大特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务并发存在的问题"><span class="nav-number">1.2.</span> <span class="nav-text">事务并发存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#脏读（dirty-read）"><span class="nav-number">1.2.1.</span> <span class="nav-text">脏读（dirty read）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可重复读（unrepeatable-read）"><span class="nav-number">1.2.2.</span> <span class="nav-text">不可重复读（unrepeatable read）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#幻读"><span class="nav-number">1.2.3.</span> <span class="nav-text">幻读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务的四大隔离级别实践"><span class="nav-number">1.3.</span> <span class="nav-text">事务的四大隔离级别实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读未提交（Read-Uncommitted）"><span class="nav-number">1.3.1.</span> <span class="nav-text">读未提交（Read Uncommitted）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#已提交读（READ-COMMITTED）"><span class="nav-number">1.3.2.</span> <span class="nav-text">已提交读（READ COMMITTED）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重复读（Repeatable-Read）"><span class="nav-number">1.3.3.</span> <span class="nav-text">可重复读（Repeatable Read）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串行化（Serializable）"><span class="nav-number">1.3.4.</span> <span class="nav-text">串行化（Serializable）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySql隔离级别的实现原理"><span class="nav-number">1.4.</span> <span class="nav-text">MySql隔离级别的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读未提交（Read-Uncommitted）-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">读未提交（Read Uncommitted）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串行化（Serializable"><span class="nav-number">1.4.2.</span> <span class="nav-text">串行化（Serializable)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC的实现原理"><span class="nav-number">1.4.3.</span> <span class="nav-text">MVCC的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#隐式字段"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">隐式字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undo日志"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">undo日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快照读-amp-当前读"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">快照读&amp;当前读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-View"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">Read View</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#已提交读（READ-COMMITTED）-存在不可重复读问题的分析历程"><span class="nav-number">1.4.4.</span> <span class="nav-text">已提交读（READ COMMITTED） 存在不可重复读问题的分析历程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重复读（Repeatable-Read）解决不可重复读问题的一次分析"><span class="nav-number">1.4.5.</span> <span class="nav-text">可重复读（Repeatable Read）解决不可重复读问题的一次分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁相关概念补充（附）："><span class="nav-number">1.4.6.</span> <span class="nav-text">锁相关概念补充（附）：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#共享锁与排他锁"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">共享锁与排他锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#记录锁（Record-Locks）"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">记录锁（Record Locks）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#间隙锁（Gap-Locks）"><span class="nav-number">1.4.6.3.</span> <span class="nav-text">间隙锁（Gap Locks）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Next-Key-Locks（临键锁）"><span class="nav-number">1.4.6.4.</span> <span class="nav-text">Next-Key Locks（临键锁）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RC级别存在幻读分析"><span class="nav-number">1.4.7.</span> <span class="nav-text">RC级别存在幻读分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RR-级别解决幻读分析"><span class="nav-number">1.4.8.</span> <span class="nav-text">RR 级别解决幻读分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安装"><span class="nav-number">2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#docker-中下载-mysql"><span class="nav-number">2.1.</span> <span class="nav-text">docker 中下载 mysql</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动"><span class="nav-number">2.2.</span> <span class="nav-text">启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进入容器"><span class="nav-number">2.3.</span> <span class="nav-text">进入容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#登录mysql"><span class="nav-number">2.4.</span> <span class="nav-text">登录mysql</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加远程登录用户"><span class="nav-number">2.5.</span> <span class="nav-text">添加远程登录用户</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhangyu"
      src="/images/%E7%8E%8B%E4%B9%9F.jpg">
  <p class="site-author-name" itemprop="name">zhangyu</p>
  <div class="site-description" itemprop="description">The world is your oyster</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zystrivego/zystrivego.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zystrivego&#x2F;zystrivego.github.io" rel="noopener" target="_blank"><i class="fab iconfont icon-Ggooglelogo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zystrivego@163.com" title="邮箱 → mailto:zystrivego@163.com" rel="noopener" target="_blank"><i class="fa iconfont icon-youxiang fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="http://music.163.com/m/user/home?id=15370305" title="音乐 → http:&#x2F;&#x2F;music.163.com&#x2F;m&#x2F;user&#x2F;home?id&#x3D;15370305" rel="noopener" target="_blank"><i class="fa iconfont icon-netease-cloud-music-line fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangyu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el         : '#valine-comments',
      path       : location.pathname,
    }, {"enable":true,"appId":"mMYlmXk0uIoNnOnvCApkjHSL-gzGzoHsz","appKey":"r09vC2BzfhUfyWS6IBiPSSjI","notify":false,"verify":false,"placeholder":"无需注册，支持Markdown格式","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"language":null,"visitor":false,"comment_count":true,"recordIP":false,"serverURLs":null}
    ));
  }, window.Valine);
});
</script>

</body>
</html>
