<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zystrivego</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zystrivego.github.io/"/>
  <updated>2024-06-10T10:28:37.464Z</updated>
  <id>https://zystrivego.github.io/</id>
  
  <author>
    <name>zhangyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://zystrivego.github.io/2024/06/10/Mybatis/"/>
    <id>https://zystrivego.github.io/2024/06/10/Mybatis/</id>
    <published>2024-06-10T09:27:09.000Z</published>
    <updated>2024-06-10T10:28:37.464Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>Mybatis备忘</p>            <i class="fa fa-quote-right"></i>          </blockquote><a id="more"></a><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="默认缓存设置"><a href="#默认缓存设置" class="headerlink" title="默认缓存设置"></a>默认缓存设置</h3><p>在MyBatis中，关于缓存设置的参数一共有2个：localCacheScope，cacheEnabled。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 有效值: true|false，默认值为true --&gt;</span><br><span class="line">&lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;!-- 有效值：SESSION|STATEMENT，默认值为SESSION --&gt;</span><br><span class="line">&lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;SESSION&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>那么这两个参数分别在什么地方使用呢？不妨先走读一下MyBatis的相关源码。</p><p>首先，来看看参数cacheEnabled的应用。</p><ul><li>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在应用程序中通过sqlSessionFactory获取一个SqlSession对象执行CRUD操作</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在DefaultSqlSessionFactory中获取SqlSession对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, autoCommit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过MyBatis配置参数构建SqlSession对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">        <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        <span class="comment">// 根据配置的Executor类型装配具体的实现类</span></span><br><span class="line">        <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>org.apache.ibatis.session.Configuration</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Configuration中根据不同的defaultExecutorType参数值装配具体的Executor实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    <span class="comment">// 根据不同的defaultExecutorType参数值装配具体的Executor实现</span></span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    <span class="comment">// 当defaultExecutorType值为BATCH时，使用BatchExecutor</span></span><br><span class="line">        executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    <span class="comment">// 当defaultExecutorType值为REUSE时，使用ReuseExecutor</span></span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 默认情况下使用SimpleExecutor</span></span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果设置cacheEnabled参数值为true,将使用CachingExecutor</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码中可以看到，MyBatis会根据配置参数defaultExecutorType的值使用不同的执行器：BatchExecutor，ReuseExecutor，SimpleExecutor。此外，当参数cacheEnabled值为true时，会使用一个特别的执行器：CachingExecutor。那么，不同的执行器有什么不同呢？他们有什么联系吗？下图为MyBatis中执行器的类图。</p><img src="/2024/06/10/Mybatis/mybatis%E6%89%A7%E8%A1%8C%E5%99%A8.png" class=""><p>OK，到这里我们就可以对MyBatis中控制缓存的2个参数做一个浅显的总结：<br><strong>（1）参数cacheEnabled控制MyBatis使用的执行器类型</strong><br><strong>（2）参数localCacheScope控制的是BaseExecutor内部的缓存策略</strong></p><h3 id="缓存实现原理分析"><a href="#缓存实现原理分析" class="headerlink" title="缓存实现原理分析"></a>缓存实现原理分析</h3><h4 id="参数localCacheScope控制的缓存策略"><a href="#参数localCacheScope控制的缓存策略" class="headerlink" title="参数localCacheScope控制的缓存策略"></a>参数localCacheScope控制的缓存策略</h4><p>在相同的SqlSession中查询同一条数据时都会命中BaseExecutor的本地缓存。也就是说通过参数localCacheScope控制的缓存策略只能在相同SqlSession内有效，因为BaseExecutor的本地缓存对象localCache是实例属性，在不同的执行器实例中都保存一个独立的本地缓存，而在不同的SqlSession中使用的是不同的执行器实例。这个关系可以通过下图描述：</p><img src="/2024/06/10/Mybatis/localCacheScope.png" class=""><p>那么，到底是不是这样的呢？我们需要进行验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 为了验证BaseExecutor内的缓存策略，需要设置cacheEnabled参数为<span class="keyword">false</span>，默认值为<span class="keyword">true</span> --&gt;</span><br><span class="line">&lt;setting name=<span class="string">"cacheEnabled"</span> value=<span class="string">"false"</span>/&gt;</span><br><span class="line">&lt;setting name=<span class="string">"localCacheScope"</span> value=<span class="string">"SESSION"</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在相同Session中查询同一条数据</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">Student student = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>).<span class="title">getStudentById</span>(1)</span>;</span><br><span class="line">System.out.println(student);</span><br><span class="line">student = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>).<span class="title">getStudentById</span>(1)</span>;</span><br><span class="line">System.out.println(student);</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure><p>对应MyBatis输出日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">method: query</span><br><span class="line">DEBUG [main] - Opening JDBC Connection</span><br><span class="line">DEBUG [main] - Created connection <span class="number">1131184547</span>.</span><br><span class="line">DEBUG [main] - ==&gt;  Preparing: select * from student where id = ? </span><br><span class="line">DEBUG [main] - ==&gt; Parameters: <span class="number">1</span>(Long)</span><br><span class="line">DEBUG [main] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">Student&#123;id=<span class="number">1</span>, name=<span class="string">'张三'</span>, age=<span class="number">23</span>, sex=<span class="number">0</span>&#125;</span><br><span class="line">method: query</span><br><span class="line">Student&#123;id=<span class="number">1</span>, name=<span class="string">'张三'</span>, age=<span class="number">23</span>, sex=<span class="number">0</span>&#125;</span><br><span class="line">DEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">436</span>c81a3]</span><br><span class="line">DEBUG [main] - Returned connection <span class="number">1131184547</span> to pool.</span><br></pre></td></tr></table></figure><p>显然，从输出日志中可以很确定地知道：在相同Session中查询同一条数据时，只有第一次会真正从数据库中查询，后续的查询都会直接从Session内的缓存中获取。而且，我们从上述相关源码中知道，只要SqlSession存在，该缓存是永远存在，不会失效。</p><h4 id="参数cacheEnabled控制的缓存策略"><a href="#参数cacheEnabled控制的缓存策略" class="headerlink" title="参数cacheEnabled控制的缓存策略"></a>参数cacheEnabled控制的缓存策略</h4><p>在了解了参数localCacheScope控制的缓存策略之后，还需要继续研究参数cacheEnabled所控制的缓存策略。从上述源码分析中已经知道，当参数cacheEnabled值为true时，MyBatis将使用CachingExecutor执行器，下面通过源码解读一下CachingExecutor到底与其他Executor实现类有什么不同。</p><ul><li>org.apache.ibatis.executor.CachingExecutor</li></ul><p>在不同的Session中查询同一条数据时都会从这个全局缓存中查询，下面通过实例来进行验证。</p><ul><li>打开全局缓存开关</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 打开全局缓存开关 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  为了验证全局缓存，在这里把Session缓存关闭 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"STATEMENT"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>定义全局缓存实例</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在xml映射器中定义全局缓存</span><br><span class="line"><span class="comment">&lt;!-- 在xml映射器中配置全局缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在xml映射器中配置全局缓存很简单，只需要在xml映射器中简单添加一个<code>&lt;cache /&gt;</code>节点即可，这里为了演示全局缓存的效果，所以不用配置详细参数，使用默认值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在接口映射器中定义全局缓存</span></span><br><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>在接口映射器中配置全局缓存通过注解<code>@CacheNamespace</code>实现，其效果与在xml映射器中通过节点<code>&lt;cache /&gt;</code>配置是一样的。</p><ul><li>验证全局缓存的作用</li></ul><p>通过参数cacheEnabled控制的缓存是全局的，所以在多个Session中使用相同SQL语句查询同一条数据时，只在第一次查询时直接查询数据库，之后的查询都会从这个全局缓存中读取数据。如下以通过xml映射器查询为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在不同Session中查询同一条数据</span></span><br><span class="line">SqlSession sqlSession1 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">Student student = sqlSession1.selectOne(<span class="string">"org.chench.test.mybatis.mapper.getStudentById"</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(student);</span><br><span class="line">sqlSession1.close();</span><br><span class="line"></span><br><span class="line">SqlSession sqlSession2 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">student = sqlSession2.selectOne(<span class="string">"org.chench.test.mybatis.mapper.getStudentById"</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(student);</span><br><span class="line">sqlSession2.close();</span><br></pre></td></tr></table></figure><p>查看MyBatis的输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">method: query</span><br><span class="line">DEBUG [main] - Cache Hit Ratio [org.chench.test.mybatis.mapper]: 0.0</span><br><span class="line">DEBUG [main] - Opening JDBC Connection</span><br><span class="line">DEBUG [main] - Created connection 1463355115.</span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt;  Preparing: select * from test where id &#x3D; ? </span><br><span class="line">DEBUG [main] - &#x3D;&#x3D;&gt; Parameters: 1(Integer)</span><br><span class="line">DEBUG [main] - &lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">Student&#123;id&#x3D;1, name&#x3D;&#39;1509690042107_haha_update_update&#39;, age&#x3D;0, sex&#x3D;0&#125;</span><br><span class="line">DEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@573906eb]</span><br><span class="line">DEBUG [main] - Returned connection 1463355115 to pool.</span><br><span class="line">method: query</span><br><span class="line">DEBUG [main] - Cache Hit Ratio [org.chench.test.mybatis.mapper]: 0.5</span><br><span class="line">Student&#123;id&#x3D;1, name&#x3D;&#39;1509690042107_haha_update_update&#39;, age&#x3D;0, sex&#x3D;0&#125;</span><br></pre></td></tr></table></figure><p>显然，从日志中很明显看到第一次查询时缓存命中率为0，第二次查询时缓存命中率为0.5，直接从缓存中取得了数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MyBatis的缓存功能同时受到localCacheScope和cacheEnabled这2个运行时参数的控制。那么我们不禁要问：为什么需要使用2个参数进行控制而不是直接使用1个参数更加简洁？实际上，2个参数控制的缓存策略是不一样，<strong>localCacheScope参数控制的缓存是Session范围内的，称为一级缓存；而cacheEnabled参数控制的缓存是全局的，称为二级缓存，这对应于不同的应用需求。</strong></p><p>显然，<strong>MyBatis的默认配置是同时开启了Session缓存和全局缓存</strong>。另外请注意：cacheEnabled参数仅仅是打开了全局缓存开关，但这并不意味着默认情况下MyBatis就会进行全局缓存。实际上，如果需要使用全局缓存，还必须在<strong>映射器中配置全局缓存实例</strong>。</p><p>【参考】<br><a href="https://www.cnblogs.com/nuccch/p/9107880.html" target="_blank" rel="noopener">深入浅出mybatis之缓存机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;Mybatis备忘&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="https://zystrivego.github.io/2024/06/10/SpringBoot/"/>
    <id>https://zystrivego.github.io/2024/06/10/SpringBoot/</id>
    <published>2024-06-10T09:13:23.000Z</published>
    <updated>2024-06-10T09:43:38.024Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>SpringBoot备忘</p>            <i class="fa fa-quote-right"></i>          </blockquote><a id="more"></a><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>Jackson序列化默认按的GMT标准时间</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;SpringBoot备忘&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据库设计基础</title>
    <link href="https://zystrivego.github.io/2024/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://zystrivego.github.io/2024/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2024-05-19T13:05:52.000Z</published>
    <updated>2024-05-19T14:52:01.369Z</updated>
    
    <content type="html"><![CDATA[<p>数据库设计方法-新奥尔良(New Orleans)方法的四个阶段:</p><ul><li><p>需求分析阶段</p></li><li><p>概念设计阶段</p></li><li><p>逻辑设计阶段</p></li><li><p>物理设计阶段</p></li></ul><a id="more"></a><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>即分析数据存储的要求，产出物有数据流图、数据字典、需求说明书。产品经理，BA该考虑的事情，编写系统需求分析报告，包括用户规格说明书和数据字典。</p><h1 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h1><p>概念设计的目的是根据需求分析的结果，将用户对数据的需求综合成一个统一的概念模型，它是整个数据库设计的关键。概念模型是现实世界和DBMS支持的数据模型之间的桥梁。</p><p>设计出E-R图，也即实体-属性图，与物理实现无关，说明有哪些实体，实体有哪些属性。让不懂数据库的业务人员也能看懂。E-R图对立于任何一种数据模型，它不为任何一种DBMS所支持。</p><p>联系：描述实体内部以及实体之间的联系。<br>通常分为三类:</p><ul><li><p>一对一联系(1:1):例如一个班级有一个班主任。</p></li><li><p>一对多联系(1:n):例如一个班级有n个学生组成。</p></li><li><p>多对多联系(m:n):例如学生选修课程。一个学生可以选修多门课程，一门课程也可以被多个学生选修。</p><h1 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h1><p>逻辑设计的任务就是把概念模型转换成某个具体的DBWS所支持的数据模型。</p></li><li><p>按照概念设计阶段建立的基本E-R图，按选定的目标数据模型(层次、网状、关系、面向对象) ,转换成相应的逻辑模型。</p></li><li><p>对于关系型数据库来说，这种转换要符合关系数据模型的原则，得到的就是逻辑数据模型。</p></li><li><p>这个阶段主要的工作就是确定关系模型里面的<strong>属性和码(或者说主键)</strong>。</p></li><li><p>比较常用的方式是使用E- R设计工具，IDEF1x方法来进行逻辑模型建设，常用的ER图表示法包括IDEF1x,IE模型的Crow’s foot，UML类图方式等。</p><h2 id="IDEF1X方法"><a href="#IDEF1X方法" class="headerlink" title="IDEF1X方法"></a>IDEF1X方法</h2><p>IDEF1X(Integration DEFinition for Information Modeling)</p></li></ul><p>信息模型集成定义。</p><p>IDEF1X是IDEF系列方法中IDEF1的扩 展版本，是在E-R (实体联系)方法的原则基础上，增加了一些规则，使语义更为丰富的一种方法。</p><p>IDEF1X特点:有四个，如下所示：</p><ul><li><p>良好的可扩展性。</p></li><li><p>简明的一致性结构。</p></li><li><p>便于理解。</p></li><li><p>可以自动化生成模型。</p><h2 id="逻辑模型中的实体"><a href="#逻辑模型中的实体" class="headerlink" title="逻辑模型中的实体"></a>逻辑模型中的实体</h2><p>实体就是描述业务的元数据。</p></li></ul><p>主键是识别实体每一个实例唯一性的标识。</p><p>只有存在外键，实体之间才会存在关系，没有外键不能建立关系。<br>根据实体的特点，划分为两类:</p><ul><li>独立型实体(Independent Entity)</li></ul><ol><li><p>直角矩形表示。</p></li><li><p>不依赖于其他实体，可以独立存在。</p></li></ol><ul><li>依赖型实体(Dependent Entity)</li></ul><ol><li><p>圆角矩形表示。</p></li><li><p>必须依赖于其它实体而存在。</p></li><li><p>依赖型实体中的主键必须是独立实体主键的一部分或者全部。</p><h2 id="范式理论"><a href="#范式理论" class="headerlink" title="范式理论"></a>范式理论</h2><h3 id="值域"><a href="#值域" class="headerlink" title="值域"></a>值域</h3><p>定义一个属性取值的有效范围</p></li></ol><p>在值域里面的值都是合法数据。</p><p>值域体现了规则。</p><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>属性的原子性，重复组概念</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>非键属性要完整依赖于主键（比如复合主键，属性不能只依赖于其中一个主键）</p><h3 id="第二范式-1"><a href="#第二范式-1" class="headerlink" title="第二范式"></a>第二范式</h3><p>非键属性不能传递依赖于主键</p><h1 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h1><ol><li>实体非正则化处理</li><li>表和字段的物理命名</li><li>确定字段类型，长度，精度等</li><li>增加逻辑模型中不存在的物理对象，比如索引，约束等。</li></ol><h2 id="反范式处理"><a href="#反范式处理" class="headerlink" title="反范式处理"></a>反范式处理</h2><p>有限的资源，有限的硬件条件提出了物理模型反范式化的需求。<br>带来数据冗余问题。<br>有可能会导致数据不一致问题。</p><ul><li>增加冗余列<br>比如订单和客户信息冗余在一个表中，违反第三范式，但是能减少join连表查询</li><li>增加重复组(repeating groups)<br>比如第一号码，第二号码，违反了第一范式，但是方便前端展示，避免了纵横转换</li><li>派生列<br>比如中年组，老年组，减少在sql中的函数计算</li></ul><h2 id="表的物理化"><a href="#表的物理化" class="headerlink" title="表的物理化"></a>表的物理化</h2><ul><li>进行反范式化操作。</li><li>决定是否要分区。</li><li>对于大表进行分区，减少IO扫描量，加速范围查询。</li><li>决定是否要拆分历史表和当前表。</li><li>历史表是冷数据，可以放在低速存储上;当前表是热数据，使用高速存储。</li><li>历史表可以使用压缩方法减少占用的存储空间。</li></ul><h2 id="字段的物理化"><a href="#字段的物理化" class="headerlink" title="字段的物理化"></a>字段的物理化</h2><ul><li>尽量使用短字段的数据类型。</li></ul><p>长度较短的数据类型不仅可以减小数据文件的大小，提升IO性能;同时也可以减小相关计算时的内存消耗，提升计算性能。比如对于整型数据，如果可以用smallint就尽量不用int，如果可以用int就尽量不用bigint。</p><ul><li>使用一致的数据类型。</li></ul><p>表关联列尽量使用相同的数据类型。如果表关联列数据类型不同，数据库必须动态地转化为相同的数据类型进行比较，这种转换会带来一定的性能消耗 。选择高效数据类型。</p><ul><li>字段的约束DEFAULT</li></ul><p>如果能够从业务层面补全字段值，就不建议使用DEFAULT约束，避免数据加载时产生不符合预期的结果</p><ul><li><p>给明确不存在NULL值的字段加上NOT NULL约束。</p></li><li><p>唯一约束/主键约束</p></li><li><p>检查约束因为对于数据质量提出了要求，不满足约束的数据在插入数据表会导致SQL失败。</p></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol><li><p>在经常需要搜索查询的列;</p></li><li><p>在作为主键的列，上创建索引，强制该列的唯一性;</p></li><li><p>在经常使用连接的列上创建索引;</p></li><li><p>在经常需要根据范围进行搜索的列上创建索引;</p></li><li><p>在经常需要排序的列上创建索引;</p></li><li><p>在经常使用WHERE子句的列上创建索引。</p></li><li><p>索引建多了，会有负面影响</p></li></ol><ul><li>占用更多的空间</li><li>插入基表数据的效率会下降</li></ul><ol start="8"><li>删除无效的索引，避免空间浪费</li></ol><h2 id="物理模型产出物"><a href="#物理模型产出物" class="headerlink" title="物理模型产出物"></a>物理模型产出物</h2><ul><li><p>物理数据模型;</p></li><li><p>物理模型命名规范;</p></li><li><p>物理数据模型设计说明书;</p></li><li><p>生成DDL建表语句。</p></li></ul><h2 id="使用建模软件"><a href="#使用建模软件" class="headerlink" title="使用建模软件"></a>使用建模软件</h2><p>使用建模软件来进行逻辑建模和物理建模，功能强大而丰富;<br>正向生成DDL，反向解析;<br>在逻辑模型和物理模型中自由切换使用视图;<br>全面满足建模中的各种需求，高效进行建模。<br>相关软件:<br>CA ERWin;<br>SAP PowerDesigner;<br>ER/Studio;<br>pgModeler;<br>Dbeaver Community;<br>datablau;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库设计方法-新奥尔良(New Orleans)方法的四个阶段:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需求分析阶段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;概念设计阶段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逻辑设计阶段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;物理设计阶段&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://zystrivego.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="https://zystrivego.github.io/2023/11/04/redis/"/>
    <id>https://zystrivego.github.io/2023/11/04/redis/</id>
    <published>2023-11-04T15:17:41.000Z</published>
    <updated>2024-05-19T15:41:50.485Z</updated>
    
    <content type="html"><![CDATA[<p>redis学习</p><a id="more"></a><h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Redis的主从复制是一种数据复制机制，它将一台Redis服务器的数据复制到其他的Redis服务器。其中，前者称为主节点（master），后者称为从节点（slave）。数据的复制是单向的，只能由主节点到从节点。默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。主从复制的作用主要包括：</p><ul><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><p>缺点：主节点挂掉后，不可用。</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>基于主从复制，它可以自动感知系统故障、自动故障转移，具备以下能力：</p><ul><li>监控（Monitoring）：持续监控Redis主节点、从节点是否处于预期的工作状态。</li><li>通知（Notification）：哨兵可以把Redis实例的运行故障信息通过API通知监控系统或者其他应用程序。</li><li>自动故障恢复（Automatic failover）：当主节点运行故障时，哨兵会启动自动故障恢复流程：某个从节点会升级为主节点，其他从节点会使用新的主节点进行主从复制，通知客户端使用新的主节点进行。</li><li>配置中心（Configuration provider）：哨兵可以作为客户端服务发现的授权源，客户端连接到哨兵请求给定服务的Redis主节点地址。如果发生故障转移，哨兵会通知新的地址。</li></ul><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>Redis集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现：一个Redis集群包含16384个哈希槽（hash slot），数据库中的每个键都属于这16384个哈希槽的其中一个，集群使用公式CRC16(key) % 16384来计算键key属于哪个槽，其中CRC16(key)语句用于计算键key的CRC16校验和。集群中的每个节点负责处理一部分哈希槽。这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。</p><p>至少需要3个节点（选举半数需要），一个节点包含一个主节点，多个从节点（主从复制）</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="redis和数据库的数据一致性"><a href="#redis和数据库的数据一致性" class="headerlink" title="redis和数据库的数据一致性"></a>redis和数据库的数据一致性</h3><h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><p>先从redis读取数据，没有再从数据库读数据，并写入到redis中</p><h4 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h4><ol><li>双删方案</li></ol><p>先删除redis，再写数据库，随机一小段时间，再删一次redis</p><ol start="2"><li>先写数据库，再删除redis</li></ol><p>其它方案，高并发场景可能读到旧数据，或者写入旧数据库到缓存</p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>因为不是原子性操作，高并发场景可能有删除失败的情况，数据同步推荐3种方式</p><ol><li>业务代码定时任务删除失败的数据</li><li>mq</li><li>binlog</li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>定义：大量key同时失效，请求打向数据库。</p><p>原因及解决措施：</p><ol><li>key的过期时间设置的一样了，解决措施：每次设置过期时间，加上一个小点的随机数</li><li>redis服务挂了，解决措施：高可用方案，集群。</li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>定义：热点key失效，请求打向数据库。</p><p>解决措施：热点key不设置过期时间</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>定义：key在redis和数据库中都不存在</p><p>原因：误删或恶意攻击</p><p>解决措施：</p><ol><li>前端参数校验</li><li>把不存在的key缓存起来，并返回空对象，设置一个短的过期时间</li><li>布隆过滤器（准确快速的判断某个数据是否在大数据量集合中，并且不占用内存），常用实现</li></ol><ul><li>redisson</li><li>lettuce</li><li>guava</li></ul><h3 id="Redis是单线程的吗"><a href="#Redis是单线程的吗" class="headerlink" title="Redis是单线程的吗"></a>Redis是单线程的吗</h3><p>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发生数据给客户端」这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。<br>但是，Redis 程序并不是单线程的，Redis 在启动的时候，是会启动后台线程的：比如持久化、 异步删除、集群数据同步等，是由额外的线程来执行的。</p><h4 id="单线程为什么还这么快？"><a href="#单线程为什么还这么快？" class="headerlink" title="单线程为什么还这么快？"></a>单线程为什么还这么快？</h4><ol><li>Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li><li>Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li><li>Redis 采用了I/O 多路复用机制处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li></ol><h4 id="Redis-6-0-之前为什么使用单线程？"><a href="#Redis-6-0-之前为什么使用单线程？" class="headerlink" title="Redis 6.0 之前为什么使用单线程？"></a>Redis 6.0 之前为什么使用单线程？</h4><p>官方回答：CPU 并不是制约 Redis 性能表现的瓶颈所在，更多情况下是受到内存大小和网络I/O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题，如果你想要使用服务的多核CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式。</p><p>除了上面的官方回答，选择单线程的原因也有下面的考虑。</p><p>使用了单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。</p><h4 id="Redis-6-0-之后为什么引入了多线程？"><a href="#Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="Redis 6.0 之后为什么引入了多线程？"></a>Redis 6.0 之后为什么引入了多线程？</h4><p>虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上。</p><p>所以为了提高网络请求处理的并行度，<strong>Redis 6.0 对于网络请求采用多线程来处理。但是对于读写命令，Redis 仍然使用单线程来处理</strong>，所以大家不要误解 Redis 有多线程同时执行命令。</p><p>Redis 官方表示，Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上。</p><p>Redis 6.0 版本支持的 I/O  多线程特性，默认是 I/O 多线程只处理写操作（write client socket），并不会以多线程的方式处理读操作（read client socket）。要想开启多线程处理客户端读请求，就需要把  Redis.conf  配置文件中的 io-threads-do-reads 配置项设为 yes。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;读请求也使用io多线程</span><br><span class="line">io-threads-do-reads yes</span><br></pre></td></tr></table></figure><p>同时， Redis.conf  配置文件中提供了  IO 多线程个数的配置项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; io-threads N，表示启用 N-1 个 I&#x2F;O 多线程（主线程也算一个 I&#x2F;O 线程）</span><br><span class="line">io-threads 4</span><br></pre></td></tr></table></figure><p>关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。因此， Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会有 6 个线程：</p><ul><li>Redis-server ：Redis的主线程，主要负责执行命令；</li><li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；</li><li>io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ol><li>避免big-key，hash更均匀</li><li>避免keys*，scan操作，影响性能</li></ol><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB-redis-database"><a href="#RDB-redis-database" class="headerlink" title="RDB(redis database)"></a>RDB(redis database)</h3><p>生成指定时间间隔内的Redis内存中<strong>数据快照</strong>，是一个<strong>二进制文件dump.rdb</strong>。RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。RDB在恢复大数据集时的速度比AOF的恢复<strong>速度要快</strong>。RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。RDB机制是通过把某个时刻的所有数据生成一个快照来保存，提供了三种触发机制：<strong>save、bgsave、自动化</strong>。<strong>推荐使用，凌晨定时任务执行，每次关闭启动的时候执行下bgsave，这样对性能比较好。</strong></p><h3 id="AOF-append-only-file"><a href="#AOF-append-only-file" class="headerlink" title="AOF(append only file)"></a>AOF(append only file)</h3><p>记录Redis除了查询以外的所有<strong>写命令</strong>，并在Redis服务启动时，通过重新执行这些命令来还原数据。AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。根据所使用的fsync策略，AOF的速度可能会比RDB慢。通常fsync设置为每秒一次就能获得比较高的性能，而关闭fsync可以让AOF的速度和RDB一样快。AOF日志文件的大小一般会比RDB文件大。AOF机制也有三种触发机制：每修改同步always、每秒同步everysec、不同步no。</p><h2 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h2><ul><li><p>Jedis是一个比较纯粹的Redis客户端，几乎没有提供什么高级功能。它的性能比较差，所以如果您不需要使用Redis的高级功能，建议使用Lettuce。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。</p></li><li><p>Lettuce是一个线程安全的Redis客户端，它满足了大多数场景需求。所有Redis用户的操作是单线程执行的，使用多连接并不能改善一个应用的性能。使用阻塞操作的通常与获得专用连接的工作线程结合在一起。使用Redis事务是使用动态连接池的典型场景，因为需要专用连接的线程数趋于动态，也就是说动态连接池的需求是有限的。</p></li><li><p>Redisson提供了很多开箱即用的Redis高级功能，如果您的应用中需要使用到Redis的高级功能，建议使用Redisson。Redisson支持分布式锁、分布式集合、分布式对象、分布式限流等功能，可以很方便地实现分布式应用。Redisson的缺点是它的性能比较差，所以不适合对性能要求比较高的场景。</p></li><li><p>spring boot date redis</p></li></ul><p>基于lettuce，Spring RedisTemplate封装方法，调用方便。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a><a href="https://redis.io/docs/interact/transactions/" target="_blank" rel="noopener">事务</a></h3><p> <a href="https://redis.io/commands/multi" target="_blank" rel="noopener"><code>MULTI</code></a>, <a href="https://redis.io/commands/exec" target="_blank" rel="noopener"><code>EXEC</code></a>, <a href="https://redis.io/commands/discard" target="_blank" rel="noopener"><code>DISCARD</code></a> and <a href="https://redis.io/commands/watch" target="_blank" rel="noopener"><code>WATCH</code></a></p><h3 id="SETNX（SET-IF-NOT-EXIST）"><a href="#SETNX（SET-IF-NOT-EXIST）" class="headerlink" title="SETNX（SET IF NOT EXIST）"></a>SETNX（SET IF NOT EXIST）</h3><p>Redis是一个单线程模型，它通过队列来实现多个客户端的请求排队执行。这意味着，在Redis中执行的每个命令都是原子性的，不会存在线程安全问题。Redis提供了多个命令可以实现原子性的操作，如SETNX、GETSET等，它们都是通过Redis的事务机制以及WATCH命令来实现的。在分布式锁的实现中，我们可以使用SETNX命令来实现锁的获取，使用DEL命令来实现锁的释放。</p><img src="/2023/11/04/redis/setnx.png" class=""><p>对应Spring RedisTemplate中的setIfAbsent()方法</p><h3 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h3><p>上述方案在高并发场景会出现死锁问题，redisson的redlock搭配集群模式可实现高可用的分布式锁。</p><p>Redisson 分布式缓存dcs</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis学习&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="缓存" scheme="https://zystrivego.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="中间件" scheme="https://zystrivego.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>sqlite</title>
    <link href="https://zystrivego.github.io/2021/09/16/sqlite/"/>
    <id>https://zystrivego.github.io/2021/09/16/sqlite/</id>
    <published>2021-09-15T16:29:21.000Z</published>
    <updated>2021-09-15T16:53:33.132Z</updated>
    
    <content type="html"><![CDATA[<p>sqlite学习笔记</p><a id="more"></a><h1 id="判断表的某一列是否存在"><a href="#判断表的某一列是否存在" class="headerlink" title="判断表的某一列是否存在"></a>判断表的某一列是否存在</h1><p>sqlite里面有一种特殊的语法<strong>pragma</strong>，其用法如下，摘自<a href="https://www.sqlite.org/pragma.html" target="_blank" rel="noopener">官方文档</a></p><p>PRAGMAs that return results and that have no side-effects can be accessed from ordinary <a href="lang_select.html">SELECT</a> statements as <a href="vtab.html#tabfunc2">table-valued functions</a>. For each participating PRAGMA, the corresponding table-valued function has the same name as the PRAGMA with a 7-character “pragma_” prefix. The PRAGMA argument and schema, if any, are passed as arguments to the table-valued function.</p><p>For example, information about the columns in an index can be read using the <a href="pragma.html#pragma_index_info">index_info pragma</a> as follows:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA index_info(&#39;idx52&#39;);</span><br></pre></td></tr></table></figure></blockquote><p>Or, the same content can be read using:</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM pragma_index_info(&#39;idx52&#39;);</span><br></pre></td></tr></table></figure></blockquote><p><strong>PRAGMA</strong> <em>schema.**</em>table_info(**table-name);</p><p>This pragma returns one row for each column in the named table. Columns in the result set include the <strong>column name</strong>, data type, whether or not the column can be NULL, and the default value for the column. The “pk” column in the result set is zero for columns that are not part of the primary key, and is the index of the column in the primary key for columns that are part of the primary key.</p><p>The table named in the table_info pragma can also be a view.</p><p><strong>eg:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cid         name        type        notnull     dflt_value  pk        </span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------  ----------</span></span><br><span class="line">0           id          integer     0                       1         </span><br><span class="line">1           name        text        0                       0</span><br></pre></td></tr></table></figure><p>上面这个表的name就是列名，则下面这个语句name不为null就可以判断该列存在了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> PRAGMA_TABLE_INFO(<span class="keyword">table</span>-<span class="keyword">name</span>) <span class="keyword">WHERE</span> <span class="keyword">name</span>=[columnName];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sqlite学习笔记&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="sql" scheme="https://zystrivego.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Java</title>
    <link href="https://zystrivego.github.io/2021/09/15/Java/"/>
    <id>https://zystrivego.github.io/2021/09/15/Java/</id>
    <published>2021-09-15T15:27:29.000Z</published>
    <updated>2024-06-10T11:02:18.108Z</updated>
    
    <content type="html"><![CDATA[<p>Java的学习笔记</p><a id="more"></a><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h2 id="常用操作及API"><a href="#常用操作及API" class="headerlink" title="常用操作及API"></a>常用操作及API</h2><img src="/2021/09/15/Java/Stream%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8AAPI.png" class=""><blockquote><p>出自Core Java Volume 2 Chapter 1</p></blockquote><p>java/util/stream/Stream.java 源码中分为以下几类</p><ul><li><p>intermediate operation.</p></li><li><p>stateful intermediate operation.</p></li><li><p>short-circuiting stateful intermediate operation.</p></li><li><p>terminal operation.</p></li><li><p>short-circuiting terminal operation.</p></li></ul><h2 id="非常用操作"><a href="#非常用操作" class="headerlink" title="非常用操作"></a>非常用操作</h2><ol><li>主要是Collectors类里的各种收集结果的约简操作</li><li>基本类型流</li><li>并行流（在多CPU，使用并发流效率最高）</li></ol><h1 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h1><p><a href="https://juejin.cn/post/6844903446185951240" target="_blank" rel="noopener">深入理解 Java try-with-resource 语法糖</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>众所周知，所有被打开的系统资源，比如流、文件或者Socket连接等，都需要被开发者手动关闭，否则随着程序的不断运行，资源泄露将会累积成重大的生产事故。</p><p>在Java的江湖中，存在着一种名为finally的功夫，它可以保证当你习武走火入魔之时，还可以做一些自救的操作。在远古时代，处理资源关闭的代码通常写在finally块中。然而，如果你同时打开了多个资源，那么将会出现噩梦般的场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BufferedInputStream bin &#x3D; null;</span><br><span class="line">        BufferedOutputStream bout &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bin &#x3D; new BufferedInputStream(new FileInputStream(new File(&quot;test.txt&quot;)));</span><br><span class="line">            bout &#x3D; new BufferedOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)));</span><br><span class="line">            int b;</span><br><span class="line">            while ((b &#x3D; bin.read()) !&#x3D; -1) &#123;</span><br><span class="line">                bout.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            if (bin !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bin.close();</span><br><span class="line">                &#125;</span><br><span class="line">                catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    if (bout !&#x3D; null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            bout.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                        catch (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>Oh My God！！！<strong>关闭资源的代码竟然比业务代码还要多</strong>！！！这是因为，我们不仅需要关闭<code>BufferedInputStream</code>，还需要保证如果关闭<code>BufferedInputStream</code>时出现了异常， <code>BufferedOutputStream</code>也要能被正确地关闭。所以我们不得不借助finally中嵌套finally大法。可以想到，打开的资源越多，finally中嵌套的将会越深！！！</p><p>更为可恶的是，Python程序员面对这个问题，竟然微微一笑很倾城地说：“这个我们一点都不用考虑的嘞~”：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2016/11/29/4694da6fecd2ed322943a0716f9bc178~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>但是兄弟莫慌！我们可以利用Java 1.7中新增的try-with-resource语法糖来打开资源，而无需码农们自己书写资源来关闭代码。妈妈再也不用担心我把手写断掉了！我们用try-with-resource来改写刚才的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TryWithResource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (BufferedInputStream bin &#x3D; new BufferedInputStream(new FileInputStream(new File(&quot;test.txt&quot;)));</span><br><span class="line">             BufferedOutputStream bout &#x3D; new BufferedOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123;</span><br><span class="line">            int b;</span><br><span class="line">            while ((b &#x3D; bin.read()) !&#x3D; -1) &#123;</span><br><span class="line">                bout.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>是不是很简单？是不是很刺激？再也不用被Python程序员鄙视了！好了，下面将会详细讲解其实现原理以及内部机制。</p><h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h2><p>为了能够配合try-with-resource，资源必须实现<code>AutoClosable</code>接口。该接口的实现类需要重写<code>close</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Connection implements AutoCloseable &#123;</span><br><span class="line">    public void sendData() &#123;</span><br><span class="line">        System.out.println(&quot;正在发送数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;正在关闭连接&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>调用类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TryWithResource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (Connection conn &#x3D; new Connection()) &#123;</span><br><span class="line">            conn.sendData();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>运行后输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正在发送数据</span><br><span class="line">正在关闭连接</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过结果我们可以看到，close方法被自动调用了。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>那么这个是怎么做到的呢？我相信聪明的你们一定已经猜到了，其实，这一切都是编译器大神搞的鬼。我们反编译刚才例子的class文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TryWithResource &#123;</span><br><span class="line">    public TryWithResource() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Connection e &#x3D; new Connection();</span><br><span class="line">            Throwable var2 &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                e.sendData();</span><br><span class="line">            &#125; catch (Throwable var12) &#123;</span><br><span class="line">                var2 &#x3D; var12;</span><br><span class="line">                throw var12;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if(e !&#x3D; null) &#123;</span><br><span class="line">                    if(var2 !&#x3D; null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            e.close();</span><br><span class="line">                        &#125; catch (Throwable var11) &#123;</span><br><span class="line">                            var2.addSuppressed(var11);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        e.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception var14) &#123;</span><br><span class="line">            var14.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>看到没，在第15~27行，编译器自动帮我们生成了finally块，并且在里面调用了资源的close方法，所以例子中的close方法会在运行的时候被执行。</p><h3 id="异常屏蔽"><a href="#异常屏蔽" class="headerlink" title="异常屏蔽"></a>异常屏蔽</h3><p>我相信，细心的你们肯定又发现了，刚才反编译的代码（第21行）比远古时代写的代码多了一个<code>addSuppressed</code>。为了了解这段代码的用意，我们稍微修改一下刚才的例子：我们将刚才的代码改回远古时代手动关闭异常的方式，并且在<code>sendData</code>和<code>close</code>方法中抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Connection implements AutoCloseable &#123;</span><br><span class="line">    public void sendData() throws Exception &#123;</span><br><span class="line">        throw new Exception(&quot;send data&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        throw new MyException(&quot;close&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>修改main方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TryWithResource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void test() throws Exception &#123;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn &#x3D; new Connection();</span><br><span class="line">            conn.sendData();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            if (conn !&#x3D; null) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>运行之后我们发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">basic.exception.MyException: close</span><br><span class="line">at basic.exception.Connection.close(Connection.java:10)</span><br><span class="line">at basic.exception.TryWithResource.test(TryWithResource.java:82)</span><br><span class="line">at basic.exception.TryWithResource.main(TryWithResource.java:7)</span><br><span class="line">......复制代码</span><br></pre></td></tr></table></figure><p>好的，问题来了，由于我们一次只能抛出一个异常，所以在最上层看到的是最后一个抛出的异常——也就是<code>close</code>方法抛出的<code>MyException</code>，而<code>sendData</code>抛出的<code>Exception</code>被忽略了。这就是所谓的异常屏蔽。由于异常信息的丢失，异常屏蔽可能会导致某些bug变得极其难以发现，程序员们不得不加班加点地找bug，如此毒瘤，怎能不除！幸好，为了解决这个问题，从Java 1.7开始，大佬们为<code>Throwable</code>类新增了<code>addSuppressed</code>方法，支持将一个异常附加到另一个异常身上，从而避免异常屏蔽。那么被屏蔽的异常信息会通过怎样的格式输出呢？我们再运行一遍刚才用try-with-resource包裹的main方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Exception: send data</span><br><span class="line"></span><br><span class="line">at basic.exception.Connection.sendData(Connection.java:5)</span><br><span class="line">at basic.exception.TryWithResource.main(TryWithResource.java:14)</span><br><span class="line">......</span><br><span class="line">Suppressed: basic.exception.MyException: close</span><br><span class="line">at basic.exception.Connection.close(Connection.java:10)</span><br><span class="line">at basic.exception.TryWithResource.main(TryWithResource.java:15)</span><br><span class="line">... 5 more复制代码</span><br></pre></td></tr></table></figure><p>可以看到，异常信息中多了一个<code>Suppressed</code>的提示，告诉我们这个异常其实由两个异常组成，<code>MyException</code>是被Suppressed的异常。可喜可贺！</p><h3 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h3><p>在使用try-with-resource的过程中，一定需要了解资源的<code>close</code>方法内部的实现逻辑。否则还是可能会导致资源泄露。</p><p>举个例子，在Java BIO中采用了大量的装饰器模式。当调用装饰器的<code>close</code>方法时，本质上是调用了装饰器内部包裹的流的<code>close</code>方法。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class TryWithResource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (FileInputStream fin &#x3D; new FileInputStream(new File(&quot;input.txt&quot;));</span><br><span class="line">                GZIPOutputStream out &#x3D; new GZIPOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123;</span><br><span class="line">            byte[] buffer &#x3D; new byte[4096];</span><br><span class="line">            int read;</span><br><span class="line">            while ((read &#x3D; fin.read(buffer)) !&#x3D; -1) &#123;</span><br><span class="line">                out.write(buffer, 0, read);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>在上述代码中，我们从<code>FileInputStream</code>中读取字节，并且写入到<code>GZIPOutputStream</code>中。<code>GZIPOutputStream</code>实际上是<code>FileOutputStream</code>的装饰器。由于try-with-resource的特性，实际编译之后的代码会在后面带上finally代码块，并且在里面调用fin.close()方法和out.close()方法。我们再来看<code>GZIPOutputStream</code>类的close方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void close() throws IOException &#123;</span><br><span class="line">    if (!closed) &#123;</span><br><span class="line">        finish();</span><br><span class="line">        if (usesDefaultDeflater)</span><br><span class="line">            def.end();</span><br><span class="line">        out.close();</span><br><span class="line">        closed &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>我们可以看到，out变量实际上代表的是被装饰的<code>FileOutputStream</code>类。在调用out变量的<code>close</code>方法之前，<code>GZIPOutputStream</code>还做了<code>finish</code>操作，该操作还会继续往<code>FileOutputStream</code>中写压缩信息，此时如果出现异常，则会<code>out.close()</code>方法被略过，然而这个才是最底层的资源关闭方法。正确的做法是应该在try-with-resource中单独声明最底层的资源，保证对应的<code>close</code>方法一定能够被调用。在刚才的例子中，我们需要单独声明每个<code>FileInputStream</code>以及<code>FileOutputStream</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TryWithResource &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (FileInputStream fin &#x3D; new FileInputStream(new File(&quot;input.txt&quot;));</span><br><span class="line">                FileOutputStream fout &#x3D; new FileOutputStream(new File(&quot;out.txt&quot;));</span><br><span class="line">                GZIPOutputStream out &#x3D; new GZIPOutputStream(fout)) &#123;</span><br><span class="line">            byte[] buffer &#x3D; new byte[4096];</span><br><span class="line">            int read;</span><br><span class="line">            while ((read &#x3D; fin.read(buffer)) !&#x3D; -1) &#123;</span><br><span class="line">                out.write(buffer, 0, read);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>由于编译器会自动生成<code>fout.close()</code>的代码，这样肯定能够保证真正的流被关闭。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Ftutorial%2Fessential%2Fexceptions%2FtryResourceClose.html">官方文档</a></li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fcn%2Farticles%2Fjava%2Ftrywithresources-401775-zhs.html">详解try-with-resource</a></li></ol><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><ol><li>阿里-SeaTa</li><li>hmily-tcc</li><li>rocketmq的事务消息</li></ol><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="基于数据库表记录的方式"><a href="#基于数据库表记录的方式" class="headerlink" title="基于数据库表记录的方式"></a>基于数据库表记录的方式</h2><p>适用于单库多服务实例的场景</p><p>表名：distributed_lock_t</p><p>字段：</p><ol><li>锁名称(lock_name)，区分业务场景</li><li>锁拥有者线程ID(owner_thread_id)，实现可重入锁，同一线程多个方法都可以获取到这把锁。</li><li>请求上下文信息(req_info)，记录获取线程的类和方法</li><li>锁获取时间(lock_acquired_time)</li><li>锁过期时间(lock_expired_time)，防止因为异常锁未释放。</li></ol><h2 id="基于redis"><a href="#基于redis" class="headerlink" title="基于redis"></a>基于redis</h2><p>详见<a href="https://zystrivego.github.io/2023/11/04/redis/#more">redis博客</a></p><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><ul><li>JDK1.7之前</li></ul><p>  在jdk1.7之前，常量池是存放在方法区中的。<br><img src="https://img-blog.csdnimg.cn/20201126173632432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlhX25ldA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>JDK1.7</li></ul><p>  在jdk1.7中，字符串常量池移到了堆中，运行时常量池还在方法区中。<br><img src="https://img-blog.csdnimg.cn/20201126173618236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlhX25ldA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>JDK1.8</li></ul><p>  jdk1.8删除了永久代，方法区这个概念还是保留的，但是方法区的实现变成了<code>元空间</code>，常量池沿用jdk1.7，还是放在了堆中。这样的效果就变成了：常量池和静态变量存储到了堆中，类的元数据及运行时常量池存储到元空间中。<br><img src="https://img-blog.csdnimg.cn/20201126172724596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FuZHlhX25ldA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>  为啥要把方法区从JVM内存（永久代）移到直接内存（元空间）？主要有两个原因：</p><ol><li>直接内存属于本地系统的IO操作，具有更高的一个IO操作性能，而JVM的堆内存这种，如果有IO操作，也是先复制到直接内存，然后再去进行本地IO操作。经过了一系列的中间流程，性能就会差一些。非直接内存操作：<code>本地IO操作——&gt;直接内存操作——&gt;非直接内存操作——&gt;直接内存操作——&gt;本地IO操作</code>，而直接内存操作：<code>本地IO操作——&gt;直接内存操作——&gt;本地IO操作</code>。</li><li>永久代有一个无法调整更改的JVM固定大小上限，回收不完全时，会出现<code>OutOfMemoryError</code>问题；而直接内存（元空间）是受到本地机器内存的限制，不会有这种问题。</li></ol><ul><li>变化</li></ul><ol><li>在JDK1.7前，运行时常量池+字符串常量池是存放在方法区中，HotSpot VM对方法区的实现称为永久代。</li><li>在JDK1.7中，字符串常量池从方法区移到堆中，运行时常量池保留在方法区中。</li><li>在JDK1.8中，HotSpot移除永久代，使用元空间代替，此时字符串常量池保留在堆中，运行时常量池保留在方法区中，只是实现不一样了，JVM内存变成了直接内存。</li></ol><p>【参考】<br><a href="https://www.cnblogs.com/Andya/p/14067618.html" target="_blank" rel="noopener">JVM——字符串常量池详解 - Andya_net - 博客园 (cnblogs.com)</a></p><p>​    </p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><ul><li><p>慢查询，低效业务代码(方案)</p></li><li><p>数据库查询太多</p></li><li><p>并发问题</p></li><li><p>内存溢出</p></li><li><p>程序配置</p></li><li><p>数据库慢(不应该用关系型)</p></li><li><p>GC停顿</p></li></ul><h2 id="PDCA循环"><a href="#PDCA循环" class="headerlink" title="PDCA循环"></a>PDCA循环</h2><ul><li>Plan</li></ul><p>通过工具分析CPU，IO，GC，时间消耗等分析性能优化关键点。指定相应方案。</p><ul><li>Do </li></ul><p>建立当前优化前程序的性能指标CPU，IO，GC，IOPS等，根据指定的方案，优化方案，编码，数据库，JVM等。</p><ul><li>Check </li></ul><p>通过工具，日志，度量出改进后的程序运行情况。通过指标对比确认优化效果。</p><ul><li>Act<br>分析当前优化的关键点，持续改进和优化，方便导入下轮plan</li></ul><h2 id="部署调优"><a href="#部署调优" class="headerlink" title="部署调优"></a>部署调优</h2><blockquote><p>-X:传递一些信息给JVM</p></blockquote><blockquote><p>-XX:设置JVM的一些高级属性</p></blockquote><ol><li><p>根据实际情况设置xms，xmx，避免使用默认值。xms默认为物理内存的1/64，xmx则是1/4，很多微服务最大堆内存都用不到1G。Jvm占用的物理内存总大小大概为2.5倍的xmx。</p></li><li><p>建议xms和xmx设置成一样值</p></li></ol><p>如果不一样，堆内存发生变化时，会扩堆或缩堆，如果xms设置过小，就会频繁GC。环境内存不富余，所有进程内存占用最大值叠加超过了物理内存最大值，则不建议。</p><ol start="3"><li>建议按实际情况设置xss值</li></ol><p>每当启动一个新线程，JVM会在虚拟机栈为它分配个线程栈。线程栈用来保存函数地址，参数，返回值信息，调用层次越深，参数，返回值越大，所需的线程栈也越大。默认值为1024KB，一般情况256KB就够了，如果内存富余不建议调整该参数。</p><h2 id="JDK工具"><a href="#JDK工具" class="headerlink" title="JDK工具"></a>JDK工具</h2><ol><li><p>jps 查看Java进程ID</p></li><li><p>jstat 监控JVM情况</p></li><li><p>jstack 查看栈信息</p></li><li><p>jmap 导出jvm堆栈信息</p></li><li><p>jhat 分析导出的堆栈信息</p></li><li><p>jinfo 查询或设置JVM属性</p></li><li><p>jcmd 向jvm发送命令</p></li></ol><h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><ul><li><p>top </p></li><li><p>sar </p></li><li><p>pidstat</p></li><li><p>vmstat </p></li><li><p>iostat</p></li><li><p><strong>mat</strong> eclipse的内存分析工具</p></li><li><p>pmap</p></li></ul><h2 id="Java监测工具"><a href="#Java监测工具" class="headerlink" title="Java监测工具"></a>Java监测工具</h2><p>jprofiler(收费)，jvisualvm（jdk）， jconslole (jdk)本地性能分析</p><p>asyncprofiler:idea绑定的profiler</p><p>arthas 线上分析</p><p>BTrace 线上分析，弱于arthas</p><h2 id="JVM优化案例"><a href="#JVM优化案例" class="headerlink" title="JVM优化案例"></a>JVM优化案例</h2><h3 id="堆内存问题"><a href="#堆内存问题" class="headerlink" title="堆内存问题"></a>堆内存问题</h3><p>问题高发区</p><p>jmap -heap pid</p><p>看老年区问题 一般都是这里溢出</p><p>jstat -gcutil pid 1000</p><p>每隔一秒打印gc快照，分析fgc和fgct是不是异常</p><p>jmap -histo pid 看哪个对象的实例最多</p><h3 id="元空间内存溢出问题"><a href="#元空间内存溢出问题" class="headerlink" title="元空间内存溢出问题"></a>元空间内存溢出问题</h3><p>引入第三方开源包可能会导致元空间不够</p><p>一个类定义在元空间中平均是4K大小，建议配置大于256M</p><h3 id="堆外内存问题"><a href="#堆外内存问题" class="headerlink" title="堆外内存问题"></a>堆外内存问题</h3><p>64M块问题 malloc_arena_max</p><p>pmap分析内存-gdb分析堆外内存-找内存信息dump</p><h3 id="GC速度慢"><a href="#GC速度慢" class="headerlink" title="GC速度慢"></a>GC速度慢</h3><p>看磁盘看CPU，看swap看文件锁，看cgroup</p><p>young gc和cms gc容易受swap虚拟内存影响</p><p>看cgroup是否限制了内存使用，把JVM的内存限制到虚拟内存上了。</p><h1 id="高性能编码"><a href="#高性能编码" class="headerlink" title="高性能编码"></a>高性能编码</h1><h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><ol><li><p>http web压测工具 ApacheBench，JMeter</p></li><li><p>JMH jdk9自带，代码微基准测试工具</p></li><li><p>单元测试:Junit5+Mockito</p></li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li><p>避免循环中使用string#match，会创建新的pattern对象。</p></li><li><p>Java8及以前的string.replace相关和split会创建新的pattern对象，避免循环调用。</p></li><li><p>避免在循环中使用string#format或message#format，使用string加号拼接或者stringbuilder</p></li></ol><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>ArrayList和linkedlist，头部的增删是linkedlist效率高，其它则是ArrayList(在不考虑扩容的情况下)</p><ol><li>避免循环中用linklist带index的方法用ArrayList代替</li><li>循环中remove带index的元素建议使用list#sublist#clear，避免重复拷贝</li><li>不变集合可以使用guava的immutablemap或immutablelist等</li><li>知道确定元素个数时，集合初始化大小，list即所需大小，map为（所需大小/0.75)+1，避免频繁动态扩容，建议使用工具类，如Guava</li><li>避免创建小集合，1-4个元素的集合，建议创建数组，数组占用16字节，ArrayList24，hashmap48</li><li>避免创建稀疏的集合，ArrayList的trimtosize可以节省空间</li><li>避免循环中使用list#contain(obj)，indexOf等相关方法，复杂度是O(m*n)，善用set，hash效率更高，list的contain是比较equals方法，set的则是先比较hashcode，再比较equals方法</li><li>system.arraycopy更高效</li></ol><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><ol><li>countdownlatch await锁主线程，实时系统多并发场景</li><li>cyclicbarrier await锁子线程，批处理系统实现任务顺序协调</li><li>semaphore，控制多线程访问有限特定资源，适合令牌节流，资源池共享</li><li>copy-on-write模式缺点:占用内存，最终一致性，适合多读少些场景。</li><li>优雅关闭线程池</li></ol><p>关闭线程池有两种方式：shutdown() 和 shutdownNow()，二者最大的区别是 shutdown() 只是把空闲的 woker 置为中断，不影响正在运行的woker，并且会继续把待执行的任务给处理完。shutdonwNow() 则是把所有的 woker 都置为中断，待执行的任务全部抽出并返回，日常工作中更多是使用 shutdown()。</p><p>最后，单纯的使用 shutdown() 也不靠谱，还得使用 awaitTermination() 和 JVM 的钩子，才算优雅的关闭线程池。</p><ol start="6"><li>IO密集性重写线程池，借鉴Tomcat，dubbo，taskqueue，threadpoolexecutor</li></ol><p>jdk的线程池是coreSize–&gt;queue–&gt;maxSize</p><p>改造后：coreSize–&gt;maxSize–&gt;queue</p><h2 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h2><ol><li>字符串优化，-XX：+useG1GC +usestringdeduplication</li><li>编译和运行时优化:内联优化，useappcds</li></ol><h2 id="web容器"><a href="#web容器" class="headerlink" title="web容器"></a>web容器</h2><ol><li>Tomcat启动优化:跳过扫描tld文件</li><li>返回数据Gzip压缩</li><li>从httpresponse获取的InputStream直接转成Java对象，不要先转string再转对象，容易造成内存占用</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java的学习笔记&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://zystrivego.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Data Structures and Algorithm Analysis in Java</title>
    <link href="https://zystrivego.github.io/2021/09/09/Data-Structures-and-Algorithm-Analysis-in-Java/"/>
    <id>https://zystrivego.github.io/2021/09/09/Data-Structures-and-Algorithm-Analysis-in-Java/</id>
    <published>2021-09-09T14:32:27.000Z</published>
    <updated>2021-09-15T16:53:48.582Z</updated>
    
    <content type="html"><![CDATA[<p>Data Structures and Algorithm Analysis in Java的学习笔记</p><a id="more"></a><h1 id="Chapter2-算法分析"><a href="#Chapter2-算法分析" class="headerlink" title="Chapter2 算法分析"></a>Chapter2 算法分析</h1><h2 id="2-4-4-运行时间中的对数"><a href="#2-4-4-运行时间中的对数" class="headerlink" title="2.4.4 运行时间中的对数"></a>2.4.4 运行时间中的对数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p><strong>定理</strong>：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。最大公约数（greatest common divisor）缩写为gcd。</p><p>gcd(a, b) = gcd(b,  a mod b)(不妨设a &gt; b且r = a mod b, r≠0)</p><p><strong>证明</strong></p><img src="/2021/09/09/Data-Structures-and-Algorithm-Analysis-in-Java/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E8%AF%81%E6%98%8E.png" class=""><h1 id="Chapter-3-表、栈和队列"><a href="#Chapter-3-表、栈和队列" class="headerlink" title="Chapter 3 表、栈和队列"></a>Chapter 3 表、栈和队列</h1><h2 id="关于for循环里增删的思考"><a href="#关于for循环里增删的思考" class="headerlink" title="关于for循环里增删的思考"></a>关于for循环里增删的思考</h2><p>Effective Java Item58 推荐多使用for-each循环</p><p>for-each循环底层还是用的迭代器，通过反编译也可以看出。</p><p>不管是增强for循环还是普通for循环都不要在内部进行增删操作，前者会触发fast-fail机制，后者add操作内存会爆掉，remove操作索引会乱。</p><p>推荐使用显示迭代器的remove方法或者Java8增加的Collection的removeIf方法（底层也是迭代器）在循环中进行删除操作。</p><h2 id="LinkedList源码解读"><a href="#LinkedList源码解读" class="headerlink" title="LinkedList源码解读"></a>LinkedList源码解读</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, and obtain the iterator&#39;s current position in the list. A ListIterator has no current element; its cursor position always lies between the element that would be returned by a call to previous() and the element that would be returned by a call to next(). An iterator for a list of length n has n+1 possible cursor positions, as illustrated by the carets (^) below:</span><br><span class="line">                        Element(0)   Element(1)   Element(2)   ... Element(n-1)</span><br><span class="line">   cursor positions:  ^            ^            ^            ^                  ^</span><br><span class="line"></span><br><span class="line">Note that the remove and set(Object) methods are not defined in terms of the cursor position; they are defined to operate on the last element returned by a call to next or previous().</span><br></pre></td></tr></table></figure><blockquote><p>以上注释出自ListIterator源码</p></blockquote><p>私有类ListItr实现了ListIterator双向迭代器，其中的remove方法line 927是针对previous的情形，另一分支则是next的情形。</p><h2 id="队列的数组实现"><a href="#队列的数组实现" class="headerlink" title="队列的数组实现"></a>队列的数组实现</h2><p>循环数组（circular array）解决front或back在数组边界时对应dequeue或enqueue的情况。</p><h1 id="Chapter4-树"><a href="#Chapter4-树" class="headerlink" title="Chapter4 树"></a>Chapter4 树</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Data Structures and Algorithm Analysis in Java的学习笔记&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://zystrivego.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>algorithm</title>
    <link href="https://zystrivego.github.io/2020/12/09/algorithm/"/>
    <id>https://zystrivego.github.io/2020/12/09/algorithm/</id>
    <published>2020-12-08T16:37:47.000Z</published>
    <updated>2022-06-01T15:18:00.355Z</updated>
    
    <content type="html"><![CDATA[<p>算法学习</p><a id="more"></a><h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h2><blockquote><p>算法导论32.4</p></blockquote><img src="/2020/12/09/algorithm/1.png" class="" title="[命名的由来]"><h3 id="算法逻辑"><a href="#算法逻辑" class="headerlink" title="算法逻辑"></a>算法逻辑</h3><img src="/2020/12/09/algorithm/2.png" class="" title="[算法逻辑]"><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p>当模式串的某个字符匹配不上时，就看前面的最长的公共前后缀是哪一段，没有就移动一格，有则前缀移动到后缀上，进而降低时间复杂度，<strong>因为这里是最长公共前后缀，所以不用担心中间会有匹配漏掉</strong>，这里可能要多想一下。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter32;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangyu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kmp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        input();</span><br><span class="line">        getNext();</span><br><span class="line">        printNext();</span><br><span class="line">        searchPatternStr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String str = "abababfefsaababafeffbaababfef";</span></span><br><span class="line">    <span class="comment">// String pattern = "abab";</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">searchPatternStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tar = <span class="number">0</span>; <span class="comment">// 主串的每个对比的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// 模式串的每个对比的位置</span></span><br><span class="line">        <span class="keyword">while</span> (tar &lt; s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[tar] == p[pos]) &#123; <span class="comment">// 匹配上了一个字符</span></span><br><span class="line">                tar++;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">                pos = next[pos - <span class="number">1</span>]; <span class="comment">// 没匹配上，模式串回溯</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tar++; <span class="comment">// 整个模式串都没匹配上，主串位置加一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pos == p.length) &#123;</span><br><span class="line">                System.out.println(<span class="string">"find a match string, the index of position:"</span>+ (tar - pos)); <span class="comment">// 匹配到一个模式串</span></span><br><span class="line">                pos = next[pos - <span class="number">1</span>]; <span class="comment">// 模式串移动最长公共前后缀</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"next array:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : next) &#123;</span><br><span class="line">            System.out.printf(<span class="string">" %d"</span>, i );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; p.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] == p[now]) &#123; <span class="comment">// 有公共前后缀</span></span><br><span class="line">                now++;</span><br><span class="line">                next[i] = now;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now != <span class="number">0</span>) &#123;</span><br><span class="line">                now = next[now - <span class="number">1</span>]; <span class="comment">// 回溯</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[i] = now; <span class="comment">// now为0，无公共前后缀</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"abababfefsaababafeffbaababfef"</span>;</span><br><span class="line">        String pattern = <span class="string">"abab"</span>;</span><br><span class="line">        s = str.toCharArray();</span><br><span class="line">        p = pattern.toCharArray();</span><br><span class="line">        next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="370-区间加法"><a href="#370-区间加法" class="headerlink" title="370 区间加法"></a>370 区间加法</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你有一个长度为 <strong>n</strong> 的数组，初始情况下所有的数字均为 <strong>0</strong>，你将会被给出 <strong>k</strong> 个更新的操作。</p><p>其中，每个操作会被表示为一个三元组：[<strong>startIndex</strong>, <strong>endIndex</strong>, <strong>inc</strong>]，你需要将子数组 A[<strong>startIndex</strong> … <strong>endIndex</strong>]（包括 startIndex 和 endIndex）增加 <strong>inc</strong>。</p><p>请你返回 <strong>k</strong> 次操作后的数组。</p><p><strong>示例:</strong></p><p>输入: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]<br>输出: [-2,0,3,5,3]<br><strong>解释:</strong></p><p>初始状态:<br>[0,0,0,0,0]</p><p>进行了操作 [1,3,2] 后的状态:<br>[0,2,2,2,0]</p><p>进行了操作 [2,4,3] 后的状态:<br>[0,2,5,5,3]</p><p>进行了操作 [0,2,-2] 后的状态:<br>[-2,0,3,5,3]</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>差分数组</strong><br>数组 a[0..n-1] 的差分数组 d[0..n-1]，其定义为：</p><ul><li>当i=0时，d[0]=a[0]</li><li>当i&gt;0时，d[i] = a[i]-a[i-1]<br><strong>求差分数组的过程，就是求前缀和数组的逆过程。</strong></li></ul><p>差分数组的优势是，<strong>对原数组某个区间范围[L,R]内加减同一个数的更新操作，反映到差分数组上，只用更新区间两端(L和R+1位置)的值。</strong><br><strong>对中间部分的更新操作，由于相邻两项之间相减（求差分）而互相抵消。</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getModifiedArray(<span class="keyword">int</span> length, <span class="keyword">int</span>[][] updates) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] originalArray = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> startIndex = updates[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> endIndex = updates[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> inc = updates[i][<span class="number">2</span>];</span><br><span class="line">            originalArray[startIndex] += inc;</span><br><span class="line">            <span class="keyword">if</span> (endIndex &lt; length - <span class="number">1</span>) &#123;</span><br><span class="line">                originalArray[endIndex + <span class="number">1</span>] -= inc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            originalArray[i] += originalArray[i -<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> originalArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法学习&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://zystrivego.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://zystrivego.github.io/2020/11/01/MySQL/"/>
    <id>https://zystrivego.github.io/2020/11/01/MySQL/</id>
    <published>2020-11-01T15:58:07.000Z</published>
    <updated>2022-08-07T04:03:34.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mysql学习总结</p></blockquote><a id="more"></a><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><img src="/2020/11/01/MySQL/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.jpg" class=""><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。</p><blockquote><p>假如A转账给B 100 元，先从A的账户里扣除 100 元，再在 B 的账户上加上 100 元。如果扣完A的100元后，还没来得及给B加上，银行系统异常了，最后导致A的余额减少了，B的余额却没有增加。所以就需要事务，将A的钱回滚回去，就是这么简单。</p></blockquote><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><img src="/2020/11/01/MySQL/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7.jpg" class=""><ul><li><strong>原子性：</strong> 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部都执行，要么都不执行。</li><li><strong>一致性：</strong> 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。</li><li><strong>隔离性：</strong> 多个事务并发访问时，事务之间是相互隔离的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。。</li><li><strong>持久性：</strong> 表示事务完成提交后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li></ul><h2 id="事务并发存在的问题"><a href="#事务并发存在的问题" class="headerlink" title="事务并发存在的问题"></a>事务并发存在的问题</h2><p>事务并发执行存在什么问题呢，换句话说就是，一个事务是怎么干扰到其他事务的呢？看例子吧~</p><p>假设现在有表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;name&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;balance&#96; int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;un_name_idx&#96; (&#96;name&#96;) USING BTREE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><p>表中有数据：</p><img src="/2020/11/01/MySQL/table1.jpg" class=""><h3 id="脏读（dirty-read）"><a href="#脏读（dirty-read）" class="headerlink" title="脏读（dirty read）"></a>脏读（dirty read）</h3><p>假设现在有两个事务A、B：</p><ul><li>假设现在A的余额是100，事务A正在准备查询Jay的余额</li><li>这时候，事务B先扣减Jay的余额，扣了10</li><li>最后A 读到的是扣减后的余额</li></ul><img src="/2020/11/01/MySQL/table2.jpg" class=""><p>由上图可以发现，事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是<strong>脏读</strong>。</p><h3 id="不可重复读（unrepeatable-read）"><a href="#不可重复读（unrepeatable-read）" class="headerlink" title="不可重复读（unrepeatable read）"></a>不可重复读（unrepeatable read）</h3><p>假设现在有两个事务A和B：</p><ul><li>事务A先查询Jay的余额，查到结果是100</li><li>这时候事务B 对Jay的账户余额进行扣减，扣去10后，提交事务</li><li>事务A再去查询Jay的账户余额发现变成了90</li></ul><img src="/2020/11/01/MySQL/table3.jpg" class=""><p>事务A又被事务B干扰到了！在事务A范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是<strong>不可重复读</strong>。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>假设现在有两个事务A、B：</p><ul><li>事务A先查询id大于2的账户记录，得到记录id=2和id=3的两条记录</li><li>这时候，事务B开启，插入一条id=4的记录，并且提交了</li><li>事务A再去执行相同的查询，却得到了id=2,3,4的3条记录了。</li></ul><img src="/2020/11/01/MySQL/table4.jpg" class=""><p>事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是<strong>幻读</strong>。</p><h2 id="事务的四大隔离级别实践"><a href="#事务的四大隔离级别实践" class="headerlink" title="事务的四大隔离级别实践"></a>事务的四大隔离级别实践</h2><p>既然并发事务存在<strong>脏读、不可重复、幻读</strong>等问题，InnoDB实现了哪几种事务的隔离级别应对呢？</p><ul><li>读未提交（Read Uncommitted）</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatable Read）</li><li>串行化（Serializable）</li></ul><h3 id="读未提交（Read-Uncommitted）"><a href="#读未提交（Read-Uncommitted）" class="headerlink" title="读未提交（Read Uncommitted）"></a>读未提交（Read Uncommitted）</h3><p>想学习一个知识点，最好的方式就是实践之。好了，我们去数据库给它设置<strong>读未提交</strong>隔离级别，实践一下吧~</p><img src="/2020/11/01/MySQL/table5.jpg" class=""><p>先把事务隔离级别设置为read uncommitted，开启事务A，查询id=1的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br><span class="line">begin;</span><br><span class="line">select * from account where id &#x3D;1;</span><br></pre></td></tr></table></figure><p>结果如下：</p><img src="/2020/11/01/MySQL/table6.jpg" class=""><p>这时候，另开一个窗口打开mysql，也把当前事务隔离级别设置为read uncommitted，开启事务B，执行更新操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br><span class="line">begin;</span><br><span class="line">update account set balance&#x3D;balance+20 where id &#x3D;1;</span><br></pre></td></tr></table></figure><p>接着回事务A的窗口，再查account表id=1的数据，结果如下：</p><img src="/2020/11/01/MySQL/table7.jpg" class=""><p>可以发现，在<strong>读未提交（Read Uncommitted）</strong> 隔离级别下，一个事务会读到其他事务未提交的数据的，即存在<strong>脏读</strong>问题。事务B都还没commit到数据库呢，事务A就读到了，感觉都乱套了。。。实际上，读未提交是隔离级别最低的一种。</p><h3 id="已提交读（READ-COMMITTED）"><a href="#已提交读（READ-COMMITTED）" class="headerlink" title="已提交读（READ COMMITTED）"></a>已提交读（READ COMMITTED）</h3><p>为了避免脏读，数据库有了比<strong>读未提交</strong>更高的隔离级别，即<strong>已提交读</strong>。</p><img src="/2020/11/01/MySQL/table8.jpg" class=""><p>把当前事务隔离级别设置为已提交读（READ COMMITTED），开启事务A，查询account中id=1的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed;</span><br><span class="line">begin;</span><br><span class="line">select * from account where id &#x3D;1;</span><br></pre></td></tr></table></figure><p>另开一个窗口打开mysql，也把事务隔离级别设置为read committed，开启事务B，执行以下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed;</span><br><span class="line">begin;</span><br><span class="line">update account set balance&#x3D;balance+20 where id &#x3D;1;</span><br></pre></td></tr></table></figure><p>接着回事务A的窗口，再查account数据，发现数据没变：</p><img src="/2020/11/01/MySQL/table9.jpg" class=""><p>我们再去到事务B的窗口执行commit操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><p>最后回到事务A窗口查询，发现数据变了：</p><img src="/2020/11/01/MySQL/table10.jpg" class=""><p>由此可以得出结论，隔离级别设置为<strong>已提交读（READ COMMITTED）</strong> 时，已经不会出现脏读问题了，当前事务只能读取到其他事务提交的数据。但是，你站在事务A的角度想想，存在其他问题吗？</p><p><strong>提交读的隔离级别会有什么问题呢？</strong></p><p>在同一个事务A里，相同的查询sql，读取同一条记录（id=1），读到的结果是不一样的，即<strong>不可重复读</strong>。所以，隔离级别设置为read committed的时候，还会存在<strong>不可重复读</strong>的并发问题。</p><h3 id="可重复读（Repeatable-Read）"><a href="#可重复读（Repeatable-Read）" class="headerlink" title="可重复读（Repeatable Read）"></a>可重复读（Repeatable Read）</h3><p>如果你的老板要求，在同个事务中，查询结果必须是一致的，即老板要求你解决不可重复的并发问题，怎么办呢？老板，臣妾办不到？来实践一下<strong>可重复读（Repeatable Read）</strong> 这个隔离级别吧~</p><img src="/2020/11/01/MySQL/table11.jpg" class=""><p>哈哈，步骤1、2、6的查询结果都是一样的，即<strong>repeatable read解决了不可重复读问题</strong>，是不是心里美滋滋的呢，终于解决老板的难题了~</p><p><strong>RR级别是否解决了幻读问题呢？</strong></p><p>再来看看网上的一个热点问题，有关于RR级别下，是否解决了幻读问题？我们来实践一下：</p><img src="/2020/11/01/MySQL/table12.jpg" class=""><p>由图可得，步骤2和步骤6查询结果集没有变化，看起来RR级别是已经解决幻读问题了~ 但是呢，<strong>RR级别还是存在这种现象</strong>：</p><img src="/2020/11/01/MySQL/table13.jpg" class=""><p>其实，上图如果事务A中，没有<code>update account set balance=200 where id=5;</code>这步操作，<code>select * from account where id&gt;2</code>查询到的结果集确实是不变，这种情况没有<strong>幻读</strong>问题。但是，有了update这个骚操作，同一个事务，相同的sql，查出的结果集不同，这个是符合了<strong>幻读</strong>的定义~</p><p>这个问题，亲爱的朋友，你觉得它算幻读问题吗？</p><h3 id="串行化（Serializable）"><a href="#串行化（Serializable）" class="headerlink" title="串行化（Serializable）"></a>串行化（Serializable）</h3><p>前面三种数据库隔离级别，都有一定的并发问题，现在放大招吧，实践SERIALIZABLE隔离级别。</p><p>把事务隔离级别设置为Serializable，开启事务A，查询account表数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">select * from account;</span><br></pre></td></tr></table></figure><p>另开一个窗口打开mysql，也把事务隔离级别设置为Serializable，开启事务B，执行插入一条数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">begin;</span><br><span class="line">insert into account(id,name,balance) value(6,&#39;Li&#39;,100);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><img src="/2020/11/01/MySQL/table14.jpg" class=""><p>由图可得，当数据库隔离级别设置为serializable的时候，事务B对表的写操作，在等事务A的读操作。其实，这是隔离级别中最严格的，读写都不允许并发。它保证了最好的安全性，性能却是个问题~</p><h2 id="MySql隔离级别的实现原理"><a href="#MySql隔离级别的实现原理" class="headerlink" title="MySql隔离级别的实现原理"></a>MySql隔离级别的实现原理</h2><p>实现隔离机制的方法主要有两种：</p><ul><li>读写锁</li><li>一致性快照读，即 MVCC</li></ul><p>MySql使用不同的锁策略(Locking Strategy)/MVCC来实现四种不同的隔离级别。RR、RC的实现原理跟MVCC有关，RU和Serializable跟锁有关。</p><h3 id="读未提交（Read-Uncommitted）-1"><a href="#读未提交（Read-Uncommitted）-1" class="headerlink" title="读未提交（Read Uncommitted）"></a>读未提交（Read Uncommitted）</h3><p><strong>官方说法：</strong></p><blockquote><p>SELECT statements are performed in a nonlocking fashion, but a possible earlier version of a row might be used. Thus, using this isolation level, such reads are not consistent.</p></blockquote><p>读未提交，采取的是读不加锁原理。</p><ul><li>事务读不加锁，不阻塞其他事务的读和写</li><li>事务写阻塞其他事务写，但不阻塞其他事务读；</li></ul><h3 id="串行化（Serializable"><a href="#串行化（Serializable" class="headerlink" title="串行化（Serializable)"></a>串行化（Serializable)</h3><p><strong>官方的说法:</strong></p><blockquote><p>InnoDB implicitly converts all plain SELECT statements to SELECT … FOR SHARE if autocommit is disabled. If autocommit is enabled, the SELECT is its own transaction. It therefore is known to be read only and can be serialized if performed as a consistent (nonlocking) read and need not block for other transactions. (To force a plain SELECT to block if other transactions have modified the selected rows, disable autocommit.)</p></blockquote><ul><li>所有SELECT语句会隐式转化为<code>SELECT ... FOR SHARE</code>，即加共享锁。</li><li>读加共享锁，写加排他锁，读写互斥。如果有未提交的事务正在修改某些行，所有select这些行的语句都会阻塞。</li></ul><h3 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h3><p>MVCC，中文叫<strong>多版本并发控制</strong>，它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。它的实现依赖于<strong>隐式字段、undo日志、快照读&amp;当前读、Read View</strong>，因此，我们先来了解这几个知识点。</p><h4 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h4><p>对于InnoDB存储引擎，每一行记录都有两个隐藏列<strong>DB_TRX_ID、DB_ROLL_PTR</strong>，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列<strong>DB_ROW_ID</strong>。</p><ul><li>DB_TRX_ID，记录每一行最近一次修改（修改/更新）它的事务ID，大小为6字节；</li><li>DB_ROLL_PTR，这个隐藏列就相当于一个指针，指向回滚段的undo日志，大小为7字节；</li><li>DB_ROW_ID，单调递增的行ID，大小为6字节；</li></ul><img src="/2020/11/01/MySQL/table15.jpg" class=""><h4 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h4><blockquote><ul><li>事务未提交的时候，修改数据的镜像（修改前的旧版本），存到undo日志里。以便事务回滚时，恢复旧版本数据，撤销未提交事务数据对数据库的影响。</li><li>undo日志是逻辑日志。可以这样认为，当delete一条记录时，undo log中会记录一条对应的insert记录，当update一条记录时，它记录一条对应相反的update记录。</li><li>存储undo日志的地方，就是<strong>回滚段</strong>。</li></ul></blockquote><p>多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（DB_ROLL_PTR）连一条<strong>Undo日志链</strong>。</p><p>我们通过例子来看一下~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from account ;</span><br><span class="line">+----+------+---------+</span><br><span class="line">| id | name | balance |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | Jay  |     100 |</span><br><span class="line">+----+------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>假设表accout现在只有一条记录，插入该该记录的事务Id为100</li><li>如果事务B（事务Id为200），对id=1的该行记录进行更新，把balance值修改为90</li></ul><p>事务B修改后，形成的<strong>Undo Log链</strong>如下：</p><img src="/2020/11/01/MySQL/table16.jpg" class=""><h4 id="快照读-amp-当前读"><a href="#快照读-amp-当前读" class="headerlink" title="快照读&amp;当前读"></a>快照读&amp;当前读</h4><p><strong>快照读：</strong></p><p>读取的是记录数据的可见版本（有旧的版本），不加锁,普通的select语句都是快照读,如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from account where id&gt;2;</span><br></pre></td></tr></table></figure><p><strong>当前读：</strong></p><p>读取的是记录数据的最新版本，显示加锁的都是当前读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from account where id&gt;2 lock in share mode; -- 加的是共享锁</span><br><span class="line">select * from  account where id&gt;2 for update; -- 加的是排他锁</span><br></pre></td></tr></table></figure><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><ul><li>Read View就是事务执行<strong>快照读</strong>时，产生的读视图。</li><li>事务执行快照读时，会生成数据库系统当前的一个快照，记录当前系统中还有哪些活跃的读写事务，把它们放到一个列表里。</li><li>Read View主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据~</li></ul><p>为了下面方便讨论Read View可见性规则，先定义几个变量</p><blockquote><ul><li>m_ids:当前系统中那些活跃的读写事务ID,它数据结构为一个List。</li><li>min_limit_id:m_ids事务列表中，最小的事务ID</li><li>max_limit_id:m_ids事务列表中，最大的事务ID</li></ul></blockquote><ul><li>如果DB_TRX_ID &lt; min_limit_id，表明生成该版本的事务在生成ReadView前已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li><li>如果DB_TRX_ID &gt; m_ids列表中最大的事务id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li><li>如果 min_limit_id =&lt;DB_TRX_ID&lt;= max_limit_id,需要判断m_ids.contains(DB_TRX_ID)，如果在，则代表Read View生成时刻，这个事务还在活跃，还没有Commit，你修改的数据，当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，修改的结果，当前事务是能看见的。</li></ul><p><strong>注意啦！！</strong> RR跟RC隔离级别，最大的区别就是：<strong>RC每次读取数据前都生成一个ReadView，而RR只在第一次读取数据时生成一个ReadView</strong>。</p><h3 id="已提交读（READ-COMMITTED）-存在不可重复读问题的分析历程"><a href="#已提交读（READ-COMMITTED）-存在不可重复读问题的分析历程" class="headerlink" title="已提交读（READ COMMITTED） 存在不可重复读问题的分析历程"></a>已提交读（READ COMMITTED） 存在不可重复读问题的分析历程</h3><p>我觉得理解一个新的知识点，最好的方法就是<strong>居于目前存在的问题/现象，去分析它</strong>的来龙去脉~ RC的实现也跟MVCC有关，RC是存在重复读并发问题的，所以我们来分析一波RC吧，先看一下执行流程</p><img src="/2020/11/01/MySQL/table17.jpg" class=""><p>假设现在系统里有A，B两个事务在执行，事务ID分别为100、200，并且假设存在的老数据，插入事务ID是50哈~</p><p><strong>事务A 先执行查询1的操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 事务A，Transaction ID 100</span><br><span class="line">begin ;</span><br><span class="line">查询1：select *  from account WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure><p><strong>事务 B 执行更新操作，id =1记录的undo日志链如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update account set balance &#x3D;balance+20 where id &#x3D;1;</span><br></pre></td></tr></table></figure><img src="/2020/11/01/MySQL/table18.jpg" class=""><p><strong>回到事务A，执行查询2的操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin ;</span><br><span class="line">查询1：select *  from account WHERE id &#x3D; 1; </span><br><span class="line">查询2：select *  from account WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure><p><strong>查询2执行分析：</strong></p><ul><li>事务A在执行到SELECT语句时，重新生成一个ReadView，因为事务B（200）在活跃，所以ReadView的m_ids列表内容就是[200]</li><li>由上图undo日志链可得，最新版本的balance为100，它的事务ID为200，在活跃事务列表里，所以当前事务（事务A）不可见。</li><li>我们继续找下一个版本，balance为100这行记录，事务Id为50，小于活跃事务ID列表最小记录200，所以这个版本可见，因此，查询2的结果，就是返回balance=100这个记录~~</li></ul><p><strong>我们回到事务B，执行提交操作，这时候undo日志链不变</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update account set balance &#x3D;balance+20 where id &#x3D;1;</span><br><span class="line">commit</span><br></pre></td></tr></table></figure><img src="/2020/11/01/MySQL/table19.jpg" class=""><p><strong>再次回到事务A，执行查询3的操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin ;</span><br><span class="line">查询1：select *  from account WHERE id &#x3D; 1; </span><br><span class="line">查询2：select *  from account WHERE id &#x3D; 1; </span><br><span class="line">查询3：select *  from account WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure><p><strong>查询3执行分析：</strong></p><ul><li>事务A在执行到SELECT语句时，重新生成一个ReadView，因为事务B（200）已经提交，不载活跃，所以ReadView的m_ids列表内容就是空的了。</li><li>所以事务A直接读取最新纪录，读取到balance =120这个版本的数据。</li></ul><p>所以，这就是RC存在不可重复读问题的过程啦</p><h3 id="可重复读（Repeatable-Read）解决不可重复读问题的一次分析"><a href="#可重复读（Repeatable-Read）解决不可重复读问题的一次分析" class="headerlink" title="可重复读（Repeatable Read）解决不可重复读问题的一次分析"></a>可重复读（Repeatable Read）解决不可重复读问题的一次分析</h3><p>我们再来分析一波，RR隔离级别是如何解决不可重复读并发问题的吧~</p><p>你可能会觉得两个并发事务的例子太简单了，好的！我们现在来点刺激的，开启三个事务~</p><img src="/2020/11/01/MySQL/table20.jpg" class=""><p>假设现在系统里有A，B，C两个事务在执行，事务ID分别为100、200，300，存量数据插入的事务ID是50~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 事务A，Transaction ID 100</span><br><span class="line">begin ;</span><br><span class="line">UPDATE account SET balance &#x3D; 1000  WHERE id &#x3D; 1;</span><br><span class="line"># 事务B，Transaction ID 200</span><br><span class="line">begin ; &#x2F;&#x2F;开个事务，占坑先</span><br></pre></td></tr></table></figure><p><strong>这时候，account表中，id =1记录的undo日志链如下：</strong></p><img src="/2020/11/01/MySQL/table21.jpg" class=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 事务C，Transaction ID 300</span><br><span class="line">begin ;</span><br><span class="line">&#x2F;&#x2F;查询1：select * from  account WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure><p><strong>查询1执行过程分析：</strong></p><ul><li>事务C在执行SELECT语句时，会先生成一个ReadView。因为事务A（100）、B（200）在活跃，所以ReadView的m_ids列表内容就是[100, 200]。</li><li>由上图undo日志链可得，最新版本的balance为1000，它的事务ID为100，在活跃事务列表里，所以当前事务（事务C）不可见。</li><li>我们继续找下一个版本，balance为100这行记录，事务Id为50，小于活跃事务ID列表最小记录100，所以这个版本可见，因此，查询1的结果，就是返回balance=100这个记录~~</li></ul><p><strong>接着，我们把事务A提交一下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 事务A，Transaction ID 100</span><br><span class="line">begin ;</span><br><span class="line">UPDATE account SET balance &#x3D; 1000  WHERE id &#x3D; 1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p><strong>在事务B中，执行更新操作，把id=1的记录balance修改为2000，更新完后，undo 日志链如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 事务B，Transaction ID 200</span><br><span class="line">begin ; &#x2F;&#x2F;开个事务，占坑先</span><br><span class="line">UPDATE account SET balance &#x3D; 2000  WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure><img src="/2020/11/01/MySQL/table22.jpg" class=""><p><strong>回到事务C，执行查询2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 事务C，Transaction ID 300</span><br><span class="line">begin ;</span><br><span class="line">&#x2F;&#x2F;查询1：select * from  account WHERE id &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;查询2：select * from  account WHERE id &#x3D; 1;</span><br></pre></td></tr></table></figure><p><strong>查询2:执行分析：</strong></p><ul><li>在RR 级别下，执行查询2的时候，因为<strong>前面ReadView已经生成过了，所以直接服用之前的ReadView</strong>，活跃事务列表为[100,200].</li><li>由上图undo日志链可得，最新版本的balance为2000，它的事务ID为200，在活跃事务列表里，所以当前事务（事务C）不可见。</li><li>我们继续找下一个版本，balance为1000这行记录，事务Id为100,也在活跃事务列表里，所以当前事务（事务C）不可见。</li><li>继续找下一个版本，balance为100这行记录，事务Id为50，小于活跃事务ID列表最小记录100，所以这个版本可见，因此，查询2的结果，也是返回balance=100这个记录~~</li></ul><h3 id="锁相关概念补充（附）："><a href="#锁相关概念补充（附）：" class="headerlink" title="锁相关概念补充（附）："></a>锁相关概念补充（附）：</h3><h4 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h4><p>InnoDB 实现了标准的行级锁，包括两种：共享锁（简称 s 锁）、排它锁（简称 x 锁）。</p><ul><li>共享锁（S锁）：允许持锁事务读取一行。</li><li>排他锁（X锁）：允许持锁事务更新或者删除一行。</li></ul><p>如果事务 T1 持有行 r 的 s 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理：</p><ul><li>T2 请求 s 锁立即被允许，结果 T1 T2 都持有 r 行的 s 锁</li><li>T2 请求 x 锁不能被立即允许</li></ul><p>如果 T1 持有 r 的 x 锁，那么 T2 请求 r 的 x、s 锁都不能被立即允许，T2 必须等待T1释放 x 锁才可以，因为X锁与任何的锁都不兼容。</p><h4 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h4><ul><li>记录锁是最简单的行锁，<strong>仅仅锁住一行</strong>。如：<code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE</code></li><li>记录锁<strong>永远都是加在索引上</strong>的，即使一个表没有索引，InnoDB也会隐式的创建一个索引，并使用这个索引实施记录锁。</li><li>会阻塞其他事务对其插入、更新、删除</li></ul><p>记录锁的事务数据（关键词：<code>lock_mode X locks rec but not gap</code>），记录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index &#96;PRIMARY&#96; of table &#96;test&#96;.&#96;t&#96; </span><br><span class="line">trx id 10078 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#39;O;;</span><br><span class="line"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure><h4 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h4><ul><li>间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。</li><li>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</li><li>间隙锁只阻止其他事务插入到间隙中，他们不阻止其他事务在同一个间隙上获得间隙锁，所以 gap x lock 和 gap s lock 有相同的作用。</li></ul><h4 id="Next-Key-Locks（临键锁）"><a href="#Next-Key-Locks（临键锁）" class="headerlink" title="Next-Key Locks（临键锁）"></a>Next-Key Locks（临键锁）</h4><p>默认情况下，在<strong>RC</strong>级别中使用。在这种情况下，使用Next-Key Locks进行搜索和索引扫描，从而防止幻读。</p><ul><li>Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。</li></ul><h3 id="RC级别存在幻读分析"><a href="#RC级别存在幻读分析" class="headerlink" title="RC级别存在幻读分析"></a>RC级别存在幻读分析</h3><p>因为RC是存在幻读问题的，所以我们先切到RC隔离级别，分析一波~</p><p>假设account表有4条数据。</p><ul><li>开启事务A，执行当前读，查询id&gt;2的所有记录。</li><li>再开启事务B，插入id=5的一条数据。</li><li>事务B插入数据成功后，再修改id=3的记录</li><li>回到事务A,再次执行id&gt;2的当前读查询</li></ul><img src="/2020/11/01/MySQL/table23.jpg" class=""><ul><li>事务B可以插入id=5的数据，却更新不了id=3的数据，陷入阻塞。证明事务A在执行当前读的时候在id =3和id=4这两条记录上加了锁，但是并没有对 id &gt; 2 这个范围加锁~</li><li>事务B陷入阻塞后，切回事务A执行当前读操作时，死锁出现。因为事务B在 insert 的时候，会在新纪录（id=5）上加锁，所以事务A再次执行当前读，想获取id&gt; 2 的记录，就需要在 id=3,4,5 这3条记录上加锁，但是 id = 5这条记录已经被事务B 锁住了，于是事务A被事务B阻塞，同时事务B还在等待 事务A释放 id = 3上的锁，最终产生了死锁。</li></ul><img src="/2020/11/01/MySQL/table24.jpg" class=""><p>因此，我们可以发现，RC隔离级别下，加锁的select, update, delete等语句，使用的是记录锁，其他事务的插入依然可以执行，因此会存在幻读</p><h3 id="RR-级别解决幻读分析"><a href="#RR-级别解决幻读分析" class="headerlink" title="RR 级别解决幻读分析"></a>RR 级别解决幻读分析</h3><p>因为RR是解决幻读问题的，怎么解决的呢，分析一波吧~</p><p>假设account表有4条数据，RR级别。</p><ul><li><p>开启事务A，执行当前读，查询id&gt;2的所有记录</p></li><li><p>再开启事务B，插入id=5的一条数据。</p><img src="/2020/11/01/MySQL/table25.jpg" class=""><p>可以发现，事务B执行插入操作时，阻塞了~因为事务A在执行select … lock in share mode的时候，不仅在 id = 3,4 这2条记录上加了锁，而且在id &gt; 2 这个范围上也加了间隙锁。</p></li></ul><p>因此，我们可以发现，RR隔离级别下，加锁的select, update, delete等语句，会使用间隙锁+ 临键锁，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻读。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="docker-中下载-mysql"><a href="#docker-中下载-mysql" class="headerlink" title="docker 中下载 mysql"></a>docker 中下载 mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name docker-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;471025 mysql</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it docker-mysql bash</span><br></pre></td></tr></table></figure><h2 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p471025</span><br></pre></td></tr></table></figure><h2 id="添加远程登录用户"><a href="#添加远程登录用户" class="headerlink" title="添加远程登录用户"></a>添加远程登录用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;471025&#39;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;</span><br></pre></td></tr></table></figure><p>远程连接不上docker中的mysql解决办法<br><a href="https://blog.csdn.net/qq_37924905/article/details/108560767" target="_blank" rel="noopener">https://blog.csdn.net/qq_37924905/article/details/108560767</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;mysql学习总结&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="sql" scheme="https://zystrivego.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>理解RESTful架构</title>
    <link href="https://zystrivego.github.io/2020/09/20/%E7%90%86%E8%A7%A3RESTful%E6%9E%B6%E6%9E%84/"/>
    <id>https://zystrivego.github.io/2020/09/20/%E7%90%86%E8%A7%A3RESTful%E6%9E%B6%E6%9E%84/</id>
    <published>2020-09-20T15:28:44.000Z</published>
    <updated>2020-09-20T15:34:15.134Z</updated>
    
    <content type="html"><![CDATA[<p>越来越多的人开始意识到，<strong>网站即软件</strong>，而且是一种新型的软件。</p><p>这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。</p><p>网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，<strong>现在我们必须考虑，如何开发在互联网环境中使用的软件。</strong></p><a id="more"></a><p><img src="http://www.ruanyifeng.com/blogimg/asset/201109/bg2011091202.jpg" alt="img"></p><p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p><p>但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。</p><p><strong>一、起源</strong></p><p>REST这个词，是<a href="http://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="noopener">Roy Thomas Fielding</a>在他2000年的<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener">博士论文</a>中提出的。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201109/bg2011091201.jpg" alt="img"></p><p>Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p><p>他这样介绍论文的写作目的：</p><blockquote><p>“本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。<strong>我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。</strong>“</p><p>(This dissertation explores a junction on the frontiers of two research disciplines in computer science: software and networking. Software research has long been concerned with the categorization of software designs and the development of design methodologies, but has rarely been able to objectively evaluate the impact of various design choices on system behavior. Networking research, in contrast, is focused on the details of generic communication behavior between systems and improving the performance of particular communication techniques, often ignoring the fact that changing the interaction style of an application can have more impact on performance than the communication protocols used for that interaction. My work is motivated by the desire to understand and evaluate the architectural design of network-based application software through principled use of architectural constraints, thereby obtaining the functional, performance, and social properties desired of an architecture. )</p></blockquote><p><strong>二、名称</strong></p><p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。</p><p>如果一个架构符合REST原则，就称它为RESTful架构。</p><p><strong>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</strong>如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p><p><strong>三、资源（Resources）</strong></p><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><p><strong>四、表现层（Representation）</strong></p><p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</strong></p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><p><strong>五、状态转化（State Transfer）</strong></p><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p><p><strong>六、综述</strong></p><p>综合上面的解释，我们总结一下什么是RESTful架构：</p><p>　　（1）每一个URI代表一种资源；</p><p>　　（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><p><strong>七、误区</strong></p><p>RESTful架构有一些典型的设计误区。</p><p><strong>最常见的一种设计错误，就是URI包含动词。</strong>因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p><p>举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p><p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p><blockquote><p>　　POST /accounts/1/transfer/500/to/2</p></blockquote><p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p><blockquote><p>　　POST /transaction HTTP/1.1<br>　　Host: 127.0.0.1<br>　　<br>　　from=1&amp;to=2&amp;amount=500.00</p></blockquote><p><strong>另一个设计误区，就是在URI中加入版本号</strong>：</p><blockquote><p>　　<a href="http://www.example.com/app/1.0/foo" target="_blank" rel="noopener">http://www.example.com/app/1.0/foo</a></p><p>　　<a href="http://www.example.com/app/1.1/foo" target="_blank" rel="noopener">http://www.example.com/app/1.1/foo</a></p><p>　　<a href="http://www.example.com/app/2.0/foo" target="_blank" rel="noopener">http://www.example.com/app/2.0/foo</a></p></blockquote><p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="http://www.informit.com/articles/article.aspx?p=1566460" target="_blank" rel="noopener">Versioning REST Services</a>）：</p><blockquote><p>　　Accept: vnd.example-com.foo+json; version=1.0</p><p>　　Accept: vnd.example-com.foo+json; version=1.1</p><p>　　Accept: vnd.example-com.foo+json; version=2.0</p></blockquote><p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">转载地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越来越多的人开始意识到，&lt;strong&gt;网站即软件&lt;/strong&gt;，而且是一种新型的软件。&lt;/p&gt;
&lt;p&gt;这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。&lt;/p&gt;
&lt;p&gt;网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，&lt;strong&gt;现在我们必须考虑，如何开发在互联网环境中使用的软件。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="https://zystrivego.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>fastjson</title>
    <link href="https://zystrivego.github.io/2020/09/11/fastjson/"/>
    <id>https://zystrivego.github.io/2020/09/11/fastjson/</id>
    <published>2020-09-10T18:53:10.000Z</published>
    <updated>2020-09-17T14:43:38.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fastjson反序列化机制"><a href="#fastjson反序列化机制" class="headerlink" title="fastjson反序列化机制"></a>fastjson反序列化机制</h1><p>fastjson提供了智能匹配的规则，下面写法会自动映射</p><p>op_id-&gt;opid-&gt;ipId</p><p>也就是说就算json字符串是’op_id’，那java变量也可以用opid或者opId，然后也可以获取相应的数据。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Runme &#123;</span><br><span class="line">static int ONE_DAY_SECONDS &#x3D; 24 * 60 * 60 * 1000;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String json &#x3D; &quot;&#123;\&quot;op-id\&quot;:1000&#125;&quot;;</span><br><span class="line">Mo mo &#x3D; JSON.parseObject(json, Mo.class);</span><br><span class="line"></span><br><span class="line">System.out.println(mo.getOpId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static class Mo &#123;</span><br><span class="line">private String opId;</span><br><span class="line"> </span><br><span class="line">public String getOpId() &#123;</span><br><span class="line">return opId;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void setOpId(String opId) &#123;</span><br><span class="line">this.opId &#x3D; opId;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理分析</p><p>那fastjson是怎么做到的呢？</p><p>看了下源代码 </p><p><a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a></p><p>发现它的逻辑如下：</p><p>文件：src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java</p><p>方法: smartMatch(String key, int[] setFlags)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldDeserializer <span class="title">smartMatch</span><span class="params">(String key, <span class="keyword">int</span>[] setFlags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        FieldDeserializer fieldDeserializer = getFieldDeserializer(key, setFlags);</span><br><span class="line">        <span class="keyword">if</span> (fieldDeserializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> smartKeyHash = TypeUtils.fnv1a_64_lower(key);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.smartMatchHashArray == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span>[] hashArray = <span class="keyword">new</span> <span class="keyword">long</span>[sortedFieldDeserializers.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sortedFieldDeserializers.length; i++) &#123;</span><br><span class="line">        hashArray[i] = TypeUtils.fnv1a_64_lower(sortedFieldDeserializers[i].fieldInfo.name);</span><br><span class="line">&#125;</span><br><span class="line">                Arrays.sort(hashArray);</span><br><span class="line"><span class="keyword">this</span>.smartMatchHashArray = hashArray;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// smartMatchHashArrayMapping</span></span><br><span class="line">            <span class="keyword">int</span> pos = Arrays.binarySearch(smartMatchHashArray, smartKeyHash);</span><br><span class="line">            <span class="keyword">boolean</span> is = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span> &amp;&amp; (is = key.startsWith(<span class="string">"is"</span>))) &#123;</span><br><span class="line">                smartKeyHash = TypeUtils.fnv1a_64_lower(key.substring(<span class="number">2</span>));</span><br><span class="line">                pos = Arrays.binarySearch(smartMatchHashArray, smartKeyHash);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (smartMatchHashArrayMapping == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">short</span>[] mapping = <span class="keyword">new</span> <span class="keyword">short</span>[smartMatchHashArray.length];</span><br><span class="line">                    Arrays.fill(mapping, (<span class="keyword">short</span>) -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sortedFieldDeserializers.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> p = Arrays.binarySearch(smartMatchHashArray, TypeUtils.fnv1a_64_lower(sortedFieldDeserializers[i].fieldInfo.name));</span><br><span class="line">                        <span class="keyword">if</span> (p &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            mapping[p] = (<span class="keyword">short</span>) i;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    smartMatchHashArrayMapping = mapping;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> deserIndex = smartMatchHashArrayMapping[pos];</span><br><span class="line">                <span class="keyword">if</span> (deserIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isSetFlag(deserIndex, setFlags)) &#123;</span><br><span class="line">                        fieldDeserializer = sortedFieldDeserializers[deserIndex];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fieldDeserializer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                FieldInfo fieldInfo = fieldDeserializer.fieldInfo;</span><br><span class="line">                <span class="keyword">if</span> ((fieldInfo.parserFeatures &amp; Feature.DisableFieldSmartMatch.mask) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Class fieldClass = fieldInfo.fieldClass;</span><br><span class="line">                <span class="keyword">if</span> (is &amp;&amp; (fieldClass != <span class="keyword">boolean</span><span class="class">.<span class="keyword">class</span> &amp;&amp; <span class="title">fieldClass</span> !</span>= Boolean<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    fieldDeserializer = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> fieldDeserializer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它里面有个重要的地方就是调用TypeUtils.fnv1a_64_lower(String)方法，分别计算传入的key(op_id)和定义的java成员变量opId，然后计算他们是否匹配。</p><p>如果匹配的话，就会覆盖。</p><p>所以，关键就在于TypeUtils.fnv1a_64_lower(String)方法实现，如下：</p><p>这个方法就是如果是’_’或者’-‘，那么就忽略，也就是如果是op_id，那么就会变成opid。</p><p>如果是大写，那么就转换成小写，也就是opId，就会变成opid。</p><p>所以op-id或者op_id，都可以匹配opId或者opid</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fnv1a_64_lower</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> hashCode = <span class="number">0xcbf29ce484222325L</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'_'</span> || ch == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>)&#123;</span><br><span class="line">               ch = (<span class="keyword">char</span>) (ch + <span class="number">32</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hashCode ^= ch;</span><br><span class="line">            hashCode *= <span class="number">0x100000001b3L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="去除json中不规范的引号和空格"><a href="#去除json中不规范的引号和空格" class="headerlink" title="去除json中不规范的引号和空格"></a>去除json中不规范的引号和空格</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = StringEscapeUtils.unescapeJson(s); \\反转义</span><br><span class="line">jsonarray.getObject(<span class="number">0</span>, String<span class="class">.<span class="keyword">class</span>)</span>; \\取json数组的第一个元素，并且会反转义字符串</span><br><span class="line">s = s.replaceAll(<span class="string">"\"[\\s]+"</span>, <span class="string">"\""</span>); \\ 去除引号后的多余空白字符</span><br><span class="line">s = s.replaceAll(<span class="string">"[\\s]+\""</span>, <span class="string">"\""</span>); \\ 去除引号前的多余空白字符</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;fastjson反序列化机制&quot;&gt;&lt;a href=&quot;#fastjson反序列化机制&quot; class=&quot;headerlink&quot; title=&quot;fastjson反序列化机制&quot;&gt;&lt;/a&gt;fastjson反序列化机制&lt;/h1&gt;&lt;p&gt;fastjson提供了智能匹配的规则，下面写法会自动映射&lt;/p&gt;
&lt;p&gt;op_id-&amp;gt;opid-&amp;gt;ipId&lt;/p&gt;
&lt;p&gt;也就是说就算json字符串是’op_id’，那java变量也可以用opid或者opId，然后也可以获取相应的数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://zystrivego.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="json" scheme="https://zystrivego.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://zystrivego.github.io/2020/09/08/Git/"/>
    <id>https://zystrivego.github.io/2020/09/08/Git/</id>
    <published>2020-09-07T18:10:28.000Z</published>
    <updated>2021-11-20T10:39:05.588Z</updated>
    
    <content type="html"><![CDATA[<p>git学习</p><a id="more"></a><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="合并多次提交"><a href="#合并多次提交" class="headerlink" title="合并多次提交"></a>合并多次提交</h2><p>idea checkou 某一分支，选中几条记录，git squash</p><h2 id="reset和revert"><a href="#reset和revert" class="headerlink" title="reset和revert"></a>reset和revert</h2><ul><li><p><strong>revert</strong>是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</p></li><li><p><strong>reset</strong>是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。</p><ol><li><p>–hard 丢弃本地记录</p></li><li><p>–mix 默认值，unstaged状态</p></li><li><p>–soft add的状态</p></li></ol></li></ul><h2 id="log和reflog"><a href="#log和reflog" class="headerlink" title="log和reflog"></a>log和reflog</h2><p>git log 命令可以显示所有提交过的版本信息，可以加上参数  –pretty=oneline，只会显示版本号和提交时的备注信息</p><p>git reflog 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）</p><h2 id="恢复误删的提交"><a href="#恢复误删的提交" class="headerlink" title="恢复误删的提交"></a>恢复误删的提交</h2><p>git reflog 找到id，再git reset id</p><h2 id="git-merge-和-git-rebase"><a href="#git-merge-和-git-rebase" class="headerlink" title="git merge 和 git rebase"></a>git merge 和 git rebase</h2><img src="/2020/09/08/Git/MergeAndRebase.png" class="" title="[git merge and git rebase]"><h1 id="git-lfs"><a href="#git-lfs" class="headerlink" title="git-lfs"></a><a href="https://git-lfs.github.com/" target="_blank" rel="noopener">git-lfs</a></h1><ol><li><p><a href="https://github.com/git-lfs/git-lfs/releases/download/v2.12.1/git-lfs-windows-v2.12.1.exe" target="_blank" rel="noopener">下载</a>并安装 Git 命令行扩展。下载并安装后，通过运行以下命令为用户帐户设置 Git LFS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><p>每个用户帐户只需运行一次。</p></li><li><p>在要使用 Git LFS 的每个 Git 存储库中，选择要管理（或直接编辑 .gitattribute）的文件类型。您可以随时配置其他文件扩展名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs track &quot;*.psd&quot;</span><br></pre></td></tr></table></figure><p>现在确保跟踪.gitattribute：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .gitattributes</span><br></pre></td></tr></table></figure><p>请注意，定义 Git LFS 应跟踪的文件类型本身不会将任何预先存在的文件转换为 Git LFS，例如其他分支上的文件或以前的提交历史记录中的文件。为此，请使用 git <a href="https://github.com/git-lfs/git-lfs/blob/master/docs/man/git-lfs-migrate.1.ronn?utm_source=gitlfs_site&utm_medium=doc_man_migrate_link&utm_campaign=gitlfs" target="_blank" rel="noopener">lfs 迁移[1]</a>命令，该命令具有一系列选项，旨在适应各种潜在用例。</p></li><li><p>没有第三步。只需像通常一样提交并推送到 GitHub。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file.psd</span><br><span class="line">git commit -m &quot;Add design file&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h1 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h1><p>最近项目用到了代码审查工具Gerrit，push代码时报错（prohibited by Gerrit），只是以前push对应的远端格式是refs/……，现在应该改为refs/for/……，可以idea 安装gerrit插件方便使用。</p><p>Gerrit 是一个基于 Git 版本控制的基于 Web 的代码审查工具 。笔者在学习它的过程中发现，要使用好它，第一步就是要理解 Change-Id</p><h2 id="理解-Change-Id"><a href="#理解-Change-Id" class="headerlink" title="理解 Change-Id"></a>理解 Change-Id</h2><p>要理解 Gerrit 的 Change-Id，我们就必须对“一次代码审查任务”有一个定义。通常，我们认为对一次完整的功能实现或 Bug 修复（即一次完整的变更）进行代码审查是合理的。而对一个半成品进行代码审查，得到的结论是不可靠的。因此，一次代码审查任务意味着是对一次变更进行审查。</p><p>Gerrit 使用 Change-Id 来标识一次变更。Change-Id 实际上就是一串字符串，类似这样：<code>Ic8aaa0728a43936cd4c6e1ed590e01ba8f0fbf5b</code></p><p>但是，一次变更通常会伴随多次 Git 提交（Commit），而且每次提交的提交是不同的 Commit Id（提交Id）。Gerrit 如何将多次提交关联到同一个 Change-Id 呢？</p><p>我们需要在每次提交时，将 Change-Id 以规定的格式放在提交消息（Commit message）的Footer 部分中（最后一行）</p><p>Change-Id 为避免与提交 Id 冲突，通常以大写字母<code>I</code>为前缀</p><h2 id="生成-Change-Id"><a href="#生成-Change-Id" class="headerlink" title="生成 Change-Id"></a>生成 Change-Id</h2><p>Change-Id 最好是自动生成，并放到提交消息指定位置，这样才能节约开发者的时间。Gerrit 提供了标准的“commit-msg”钩子来实现。</p><p>Git 提供了4个提交工作流钩子：pre-commit、prepare-commit-msg、commit-msg、post-commit。其中 commit-msg 钩子，会在我们执行 <code>git commit</code> 时被执行。</p><p>本质上，commit-msg 钩子是一段脚本程序，放在 .git/hooks 目录下。commit-msg 脚本可以使用 Shell、Ruby、Python 等语言实现。</p><p>Gerrit 的 commit-msg 钩子直接从 Gerrit 下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 在项目目录下</span><br><span class="line">curl -Lo .git&#x2F;hooks&#x2F;commit-msg http:&#x2F;&#x2F;&lt;gerrit服务地址&gt;&#x2F;tools&#x2F;hooks&#x2F;commit-msg</span><br><span class="line">chmod u+x .git&#x2F;hooks&#x2F;commit-msg</span><br></pre></td></tr></table></figure><p>接下来，在我们执行 <code>git commit</code> 后，再执行 git log 就可以看到 Change-Id 了。</p><p>请注意，第一次 clone 代码到本地时，需要重新安装一次 commit-msg 钩子。因为它并不会被提交到版本库中。</p><p>GitLab 也有类似的 Change-Id</p><p>在 GitLab 中，每个 Issue 都会有一个 Id。它是如何将 Issue Id 与 Commit Id 关联起来的呢？GitLab 的解决方案与 Gerrit 一样。只不过，GitLab 是在提交消息的第一行开始加入 Issue Id，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;project name&gt;#&lt;Issue Id&gt;: &lt;commit msg&gt;</span><br></pre></td></tr></table></figure><h1 id="difference-between-HEAD-and-HEAD"><a href="#difference-between-HEAD-and-HEAD" class="headerlink" title="difference between HEAD^ and HEAD~ "></a><a href="https://stackoverflow.com/questions/2221658/whats-the-difference-between-head-and-head-in-git" target="_blank" rel="noopener">difference between HEAD^ and HEAD~ </a></h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git学习&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://zystrivego.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="https://zystrivego.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>快捷方式</title>
    <link href="https://zystrivego.github.io/2020/06/02/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <id>https://zystrivego.github.io/2020/06/02/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</id>
    <published>2020-06-02T07:02:02.000Z</published>
    <updated>2020-09-20T15:35:16.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其他键盘快捷方式"><a href="#其他键盘快捷方式" class="headerlink" title="其他键盘快捷方式"></a>其他键盘快捷方式</h1><ul><li><a href="https://support.microsoft.com/zh-cn/help/13805" target="_blank" rel="noopener">应用中的键盘快捷方式</a></li><li><a href="https://support.microsoft.com/zh-cn/help/13810" target="_blank" rel="noopener">用于辅助功能的 Windows 键盘快捷方式</a></li><li><a href="https://support.microsoft.com/zh-cn/help/13813" target="_blank" rel="noopener">Microsoft Surface Hub 键盘快捷方式</a></li><li><a href="https://support.microsoft.com/zh-cn/help/13781" target="_blank" rel="noopener">适用于手机的 Continuum 中的键盘快捷方式</a></li></ul><hr><a id="more"></a><h1 id="Microsoft-Edge"><a href="#Microsoft-Edge" class="headerlink" title="Microsoft Edge"></a><a href="https://support.microsoft.com/zh-cn/help/4531783/microsoft-edge-keyboard-shortcuts" target="_blank" rel="noopener">Microsoft Edge</a></h1><hr><table><thead><tr><th><strong>按此键</strong></th><th><strong>执行的操作</strong></th></tr></thead><tbody><tr><td><strong>Ctrl + D</strong></td><td>将当前网页另存为收藏夹</td></tr><tr><td><strong>Ctrl + E</strong></td><td>在地址栏中打开搜索查询</td></tr><tr><td><strong>Ctrl + F</strong></td><td>在页面上查找</td></tr><tr><td><strong>Ctrl + G</strong></td><td>跳转到“查找栏”搜索结果中的下一个匹配项</td></tr><tr><td><strong>Ctrl + H</strong></td><td>在新标签页中打开“历史记录”(Web UI)</td></tr><tr><td><strong>Ctrl + J</strong></td><td>在新标签页中打开“下载”(Web UI)</td></tr><tr><td><strong>Ctrl + L</strong></td><td>选择地址栏中的 URL 以进行编辑</td></tr><tr><td><strong>Ctrl + M</strong></td><td>将当前标签页设为静音（切换）</td></tr><tr><td><strong>Ctrl + N</strong></td><td>打开新窗口</td></tr><tr><td><strong>Ctrl + O</strong></td><td>在 Microsoft Edge 中打开计算机中的文件</td></tr><tr><td><strong>Ctrl + P</strong></td><td>打印当前页</td></tr><tr><td><strong>Ctrl + R</strong></td><td>重新加载当前页</td></tr><tr><td><strong>Ctrl + S</strong></td><td>保存当前页</td></tr><tr><td><strong>Ctrl + Shift + B</strong></td><td>显示或隐藏收藏夹栏</td></tr><tr><td><strong>Ctrl + Shift + D</strong></td><td>在新文件夹中将所有打开的标签页另存为收藏夹</td></tr><tr><td><strong>Ctrl + Shift + G</strong></td><td>跳转到“查找栏”搜索结果中的上一个匹配项</td></tr><tr><td><strong>Ctrl + Shift + I</strong></td><td>打开开发人员工具</td></tr><tr><td><strong>Ctrl + Shift + L</strong></td><td>粘贴并搜索或粘贴并访问（如果它是 URL）</td></tr><tr><td><strong>Ctrl + Shift + M</strong></td><td>以其他用户身份登录或以来宾身份浏览</td></tr><tr><td><strong>Ctrl + Shift + N</strong></td><td>打开新的 InPrivate 窗口</td></tr><tr><td><strong>Ctrl + Shift + O</strong></td><td>打开收藏夹管理</td></tr><tr><td><strong>Ctrl + Shift + P</strong></td><td>使用系统对话框打印</td></tr><tr><td><strong>Ctrl + Shift + R</strong></td><td>重新加载当前页，忽略缓存的内容</td></tr><tr><td><strong>Ctrl + Shift + T</strong></td><td>重新打开上一个关闭的标签页并切换到该标签页</td></tr><tr><td><strong>Ctrl + Shift + V</strong></td><td>不带格式粘贴</td></tr><tr><td><strong>Ctrl + Shift + W</strong></td><td>关闭当前窗口</td></tr><tr><td><strong>Ctrl + T</strong></td><td>打开新标签页并切换到该标签页</td></tr><tr><td><strong>Ctrl + U</strong></td><td>查看源</td></tr><tr><td><strong>Ctrl + W</strong></td><td>关闭当前标签页</td></tr><tr><td><strong>Ctrl + 0</strong>（零）</td><td>重置缩放级别</td></tr><tr><td><strong>Ctrl + 1、2…8</strong></td><td>切换到特定标签页</td></tr><tr><td><strong>Ctrl + 9</strong></td><td>切换到最后一个标签页</td></tr><tr><td><strong>Ctrl + Enter</strong></td><td>将 www. 和 .com 分别添加到在地址栏中键入的文本的开头和末尾</td></tr><tr><td><strong>Ctrl + Shift + Delete</strong></td><td>打开清除浏览数据选项</td></tr><tr><td><strong>Ctrl + Tab</strong></td><td>切换到下一个标签页</td></tr><tr><td><strong>Ctrl + Shift + Tab</strong></td><td>切换到上一个标签页</td></tr><tr><td><strong>Ctrl + 加号</strong> (+)</td><td>放大</td></tr><tr><td><strong>Ctrl + 减号</strong> (-)</td><td>缩小</td></tr><tr><td><strong>Ctrl + \</strong>（在 PDF 中）</td><td>在“根据页面调整”与“根据宽度调整”之间切换 PDF</td></tr><tr><td><strong>Ctrl + [</strong>（在 PDF 中）</td><td>将 PDF 逆时针旋转 90 度*</td></tr><tr><td><strong>Ctrl + ]</strong>（在 PDF 中）</td><td>将 PDF 顺时针旋转 90 度*</td></tr><tr><td><strong>Ctrl + PgDn</strong></td><td>切换到下一个标签页</td></tr><tr><td><strong>Ctrl + PgUp</strong></td><td>切换到上一个标签页</td></tr><tr><td><strong>Alt</strong></td><td>将焦点放在“设置及更多…”按钮上</td></tr><tr><td><strong>Alt + Shift + B</strong></td><td>将焦点放在收藏夹栏中的第一项上</td></tr><tr><td><strong>Alt + D</strong></td><td>选择地址栏中的 URL 以进行编辑</td></tr><tr><td><strong>Alt + E</strong></td><td>打开“设置及更多…”菜单</td></tr><tr><td><strong>Alt + F</strong></td><td>打开“设置及更多…”菜单</td></tr><tr><td><strong>Alt + Shift + I</strong></td><td>打开“发送反馈”对话框</td></tr><tr><td><strong>Alt + Shift + T</strong></td><td>将焦点放在工具栏中的第一项上</td></tr><tr><td><strong>Alt + 向左键</strong></td><td>返回</td></tr><tr><td><strong>Alt + 向右键</strong></td><td>前进</td></tr><tr><td><strong>Alt + Home</strong></td><td>在当前标签页中打开主页</td></tr><tr><td><strong>Alt + F4</strong></td><td></td></tr><tr><td>关闭当前窗口</td><td></td></tr><tr><td><strong>F1</strong></td><td>打开帮助</td></tr><tr><td><strong>F3</strong></td><td>在页面上查找</td></tr><tr><td><strong>F4</strong></td><td>选择地址栏中的 URL</td></tr><tr><td><strong>Ctrl + F4</strong></td><td>关闭当前标签页</td></tr><tr><td><strong>F5</strong></td><td>重新加载当前页</td></tr><tr><td><strong>Shift + F5</strong></td><td>重新加载当前页，忽略缓存的内容</td></tr><tr><td><strong>F6</strong></td><td>将焦点切换到下一个窗格</td></tr><tr><td><strong>Shift + F6</strong></td><td>将焦点切换到上一个窗格</td></tr><tr><td><strong>F7</strong></td><td>打开或关闭插入光标浏览</td></tr><tr><td><strong>F10</strong></td><td>将焦点放在“设置及更多…”按钮上</td></tr><tr><td><strong>F10 + Enter</strong></td><td>打开“设置及更多…”菜单</td></tr><tr><td><strong>Shift + F10</strong></td><td>打开上下文菜单</td></tr><tr><td><strong>F11</strong></td><td>进入全屏（切换）</td></tr><tr><td><strong>F12</strong></td><td>打开开发人员工具</td></tr><tr><td><strong>Esc</strong></td><td>停止加载页面；关闭对话框或弹出窗口</td></tr><tr><td><strong>空格键</strong></td><td>向下滚动网页，一次滚动一个屏幕</td></tr><tr><td><strong>Shift + 空格键</strong></td><td>向上滚动网页，一次滚动一个屏幕</td></tr><tr><td><strong>PgDn</strong></td><td>向下滚动网页，一次滚动一个屏幕</td></tr><tr><td><strong>PgUp</strong></td><td>向上滚动网页，一次滚动一个屏幕</td></tr><tr><td><strong>Home</strong></td><td>转到页面顶部，将键盘焦点移动到窗格的第一项</td></tr><tr><td><strong>End</strong></td><td>转到页面底部，将键盘焦点移动到窗格的最后一项</td></tr><tr><td><strong>Tab</strong></td><td>转到下一个制表位</td></tr><tr><td><strong>Shift + Tab</strong></td><td>转到上一个制表位</td></tr></tbody></table><hr><p>上次更新时间：2020年4月14日</p><h1 id="Windows-10"><a href="#Windows-10" class="headerlink" title="Windows 10"></a><a href="https://support.microsoft.com/zh-cn/help/12445" target="_blank" rel="noopener">Windows 10</a></h1><h2 id="复制、粘贴及其他常规的键盘快捷方式"><a href="#复制、粘贴及其他常规的键盘快捷方式" class="headerlink" title="复制、粘贴及其他常规的键盘快捷方式"></a><a href="https://support.microsoft.com/" target="_blank" rel="noopener">复制、粘贴及其他常规的键盘快捷方式</a></h2><table><thead><tr><th>按该键</th><th>执行以下操作</th></tr></thead><tbody><tr><td>Ctrl + X</td><td>剪切选定项。</td></tr><tr><td>Ctrl + C（或 Ctrl + Insert）</td><td>复制选定项。</td></tr><tr><td>Ctrl + V（或 Shift + Insert）</td><td>粘贴选定项。</td></tr><tr><td>Ctrl + Z</td><td>撤消操作。</td></tr><tr><td>Alt + Tab</td><td>在打开的应用之间切换。</td></tr><tr><td>Alt + F4</td><td>关闭活动项，或者退出活动应用。</td></tr><tr><td>Windows 徽标键 + L</td><td>锁定你的电脑。</td></tr><tr><td>Windows 徽标键 + D</td><td>显示和隐藏桌面。</td></tr><tr><td>F2</td><td>重命名所选项目。</td></tr><tr><td>F3</td><td>在文件资源管理器中搜索文件或文件夹。</td></tr><tr><td>F4</td><td>在文件资源管理器中显示地址栏列表。</td></tr><tr><td>F5</td><td>刷新活动窗口。</td></tr><tr><td>F6</td><td>循环浏览窗口中或桌面上的屏幕元素。</td></tr><tr><td>F10</td><td>激活活动应用中的菜单栏。</td></tr><tr><td>Alt + F8</td><td>在登录屏幕上显示你的密码。</td></tr><tr><td>Alt + Esc</td><td>按项目打开顺序循环浏览。</td></tr><tr><td>Alt + 带下划线的字母</td><td>执行该字母相关的命令。</td></tr><tr><td>Alt + Enter</td><td>显示所选项目的属性。</td></tr><tr><td>Alt + 空格键</td><td>打开活动窗口的快捷菜单。</td></tr><tr><td>Alt + 向左键</td><td>返回。</td></tr><tr><td>Alt + 向右键</td><td>前进。</td></tr><tr><td>Alt + Page Up</td><td>向上移动一个屏幕。</td></tr><tr><td>Alt + Page Down</td><td>向下移动一个屏幕。</td></tr><tr><td>Ctrl + F4</td><td>关闭活动文档（在可全屏显示并允许你同时打开多个文档的应用中）。</td></tr><tr><td>Ctrl + A</td><td>选择文档或窗口中的所有项目。</td></tr><tr><td>Ctrl + D（或 Delete）</td><td>删除选定项，将其移至回收站。</td></tr><tr><td>Ctrl + R（或 F5）</td><td>刷新活动窗口。</td></tr><tr><td>Ctrl + Y</td><td>恢复操作。</td></tr><tr><td>Ctrl + 向右键</td><td>将光标移动到下一个字词的起始处。</td></tr><tr><td>Ctrl + 向左键</td><td>将光标移动到上一个字词的起始处。</td></tr><tr><td>Ctrl + 向下键</td><td>将光标移动到下一段落的起始处。</td></tr><tr><td>Ctrl + 向上键</td><td>将光标移动到上一段落的起始处。</td></tr><tr><td>Ctrl + Alt + Tab</td><td>使用箭头键在所有打开的应用之间进行切换。</td></tr><tr><td>Alt + Shift + 箭头键</td><td>当组或磁贴的焦点放在“开始”菜单上时，可将其朝指定方向移动。</td></tr><tr><td>Ctrl + Shift + 箭头键</td><td>当磁贴的焦点放在“开始”菜单上时，将其移到另一个磁贴即可创建一个文件夹。</td></tr><tr><td>Ctrl + 箭头键</td><td>打开“开始”菜单后调整其大小。</td></tr><tr><td>Ctrl + 箭头键（移至某个项目）+ 空格键</td><td>选择窗口中或桌面上的多个单独项目。</td></tr><tr><td>Ctrl + Shift（及箭头键）</td><td>选择文本块。</td></tr><tr><td>Ctrl + Esc</td><td>打开“开始”菜单。</td></tr><tr><td>Ctrl + Shift + Esc</td><td>打开任务管理器。</td></tr><tr><td>Ctrl + Shift</td><td>如果多种键盘布局可用，则可切换键盘布局。</td></tr><tr><td>Ctrl + 空格键</td><td>打开或关闭中文输入法编辑器 (IME)。</td></tr><tr><td>Shift + F10</td><td>显示选定项的快捷菜单。</td></tr><tr><td>按 Shift 与任何箭头键</td><td>在窗口中或桌面上选择多个项目，或在文档中选择文本。</td></tr><tr><td>Shift + Delete</td><td>删除选定项，无需先移动到回收站。</td></tr><tr><td>向右键</td><td>打开右侧的下一个菜单，或打开子菜单。</td></tr><tr><td>向左键</td><td>打开左侧的下一个菜单，或关闭子菜单。</td></tr><tr><td>Esc</td><td>停止或离开当前任务。</td></tr><tr><td>PrtScn</td><td>捕获整个屏幕的屏幕截图并将其复制到剪贴板。 注意你可以更改此快捷方式，以便它还可以打开屏幕截取，这允许你编辑屏幕截图。依次选择“开始”菜单 &gt;“设置” &gt;“轻松访问” &gt;“键盘”，然后打开“Print Screen 快捷方式”下的切换开关。<a href="ms-settings:easeofaccess-keyboard?activationSource=SMC-Article-12445">使用 PrtScn 键打开屏幕截取</a></td></tr></tbody></table><h2 id="Windows-徽标键键盘快捷方式"><a href="#Windows-徽标键键盘快捷方式" class="headerlink" title="Windows 徽标键键盘快捷方式"></a><a href="https://support.microsoft.com/" target="_blank" rel="noopener">Windows 徽标键键盘快捷方式</a></h2><table><thead><tr><th>按该键</th><th>执行以下操作</th></tr></thead><tbody><tr><td>Windows 徽标键</td><td>打开或关闭“开始”菜单。</td></tr><tr><td>Windows 徽标键 + A</td><td>打开操作中心。</td></tr><tr><td>Windows 徽标键 + B</td><td>将焦点设置到通知区域。</td></tr><tr><td>Windows 徽标键 + C</td><td>在侦听模式下打开 Cortana。  注意此快捷方式默认情况下处于关闭状态。若要打开它，请选择“开始”菜单 &gt; “设置” &gt; “Cortana”，并打开“当我按 Windows 徽标键 + C 时，让 Cortana 听我的命令”下的切换开关。Cortana 仅在某些国家/地区可用，并且某些 Cortana 功能可能无法随时随地使用。如果 Cortana 不可用或已关闭，你仍然可以使用<a href="https://support.microsoft.com/zh-cn/help/10748" target="_blank" rel="noopener">搜索</a>。</td></tr><tr><td>Windows 徽标键 + Shift + C</td><td>打开超级按钮菜单。</td></tr><tr><td>Windows 徽标键 + D</td><td>显示和隐藏桌面。</td></tr><tr><td>Windows 徽标键 + Alt + D</td><td>显示和隐藏桌面上的日期和时间。</td></tr><tr><td>Windows 徽标键 + E</td><td>打开文件资源管理器。</td></tr><tr><td>Windows 徽标键 + F</td><td>打开反馈中心并获取屏幕截图。</td></tr><tr><td>Windows 徽标键 + G</td><td>打开游戏栏（当游戏处于打开状态时）。</td></tr><tr><td>Windows 徽标键 ‌ + H</td><td>开始听写。</td></tr><tr><td>Windows 徽标键 + I</td><td>打开设置。</td></tr><tr><td>Windows 徽标键‌ + J</td><td>将焦点设置到可用的 Windows 提示。  当出现 Windows 提示时，请将焦点移到提示上。 再次按下键盘快捷方式，将焦点放在屏幕上 Windows 提示所固定的元素上。</td></tr><tr><td>Windows 徽标键 + K</td><td>打开“连接”快速操作.</td></tr><tr><td>Windows 徽标键 + L</td><td>锁定你的电脑或切换帐户。</td></tr><tr><td>Windows 徽标键 + M</td><td>最小化所有窗口。</td></tr><tr><td>Windows 徽标键 + O</td><td>锁定设备方向。</td></tr><tr><td>Windows 徽标键 + P</td><td>选择演示显示模式。</td></tr><tr><td>Windows 徽标键 + Ctrl + Q</td><td>打开快速助手。</td></tr><tr><td>Windows 徽标键 + R</td><td>打开“运行”对话框。</td></tr><tr><td>Windows 徽标键 + S</td><td>打开搜素。</td></tr><tr><td>Windows 徽标键 + Shift + S</td><td>获取部分屏幕的屏幕截图。</td></tr><tr><td>Windows 徽标键 + T</td><td>循环浏览任务栏上的应用。</td></tr><tr><td>Windows 徽标键 + U</td><td>打开轻松使用设置中心。</td></tr><tr><td>Windows 徽标键 + V</td><td>打开剪贴板。 注意若要激活此快捷方式，请依次选择“开始”菜单 &gt; “设置” &gt; “系统” &gt; “剪贴板”，然后打开“剪贴板历史记录”下的切换开关。</td></tr><tr><td>Windows 徽标键 + Shift + V</td><td>循环浏览通知。</td></tr><tr><td>Windows 徽标键 + X</td><td>打开“快速链接”菜单。</td></tr><tr><td>Windows 徽标键 + Y</td><td>在 Windows Mixed Reality 与桌面之间切换输入。</td></tr><tr><td>Windows 徽标键 + Z</td><td>以全屏模式显示应用中可用的命令。</td></tr><tr><td>Windows 徽标键 + 句点 (.) 或分号 (;)</td><td>打开表情符号面板。</td></tr><tr><td>Windows 徽标键 + 逗号 (,)</td><td>临时速览桌面。</td></tr><tr><td>Windows 徽标键 + Pause</td><td>显示“系统属性”对话框。</td></tr><tr><td>Windows 徽标键 + Ctrl + F</td><td>搜索电脑（如果已连接到网络）。</td></tr><tr><td>Windows 徽标键 + Shift + M</td><td>还原桌面上的最小化窗口。</td></tr><tr><td>Windows 徽标键 + 数字</td><td>打开桌面，然后启动固定到任务栏的应用（位于数字所指明的位置）。如果应用已处于运行状态，则切换至该应用。</td></tr><tr><td>Windows 徽标键 + Shift + 数字</td><td>打开桌面，然后启动固定到任务栏的应用新实例（位于数字所指明的位置）。</td></tr><tr><td>Windows 徽标键 + Ctrl + 数字</td><td>打开桌面，然后切换至固定到任务栏的应用的最后活动窗口（位于数字所指明的位置）。</td></tr><tr><td>Windows 徽标键 + Alt + 数字</td><td>打开桌面，然后打开固定到任务栏的应用的“跳转列表”（位于数字所指明的位置）。</td></tr><tr><td>Windows 徽标键 + Ctrl + Shift + 数字</td><td>打开桌面，然后以管理员身份打开位于任务栏上指定位置的应用新实例。</td></tr><tr><td>Windows 徽标键 + Tab</td><td>打开任务视图。</td></tr><tr><td>Windows 徽标键 + 向上键</td><td>最大化窗口。</td></tr><tr><td>Windows 徽标键 + 向下键</td><td>删除屏幕上的当前应用并最小化桌面窗口。</td></tr><tr><td>Windows 徽标键 + 向左键</td><td>最大化屏幕左侧的应用或桌面窗口。</td></tr><tr><td>Windows 徽标键 + 向右键</td><td>最大化屏幕右侧的应用或桌面窗口。</td></tr><tr><td>Windows 徽标键 + Home</td><td>最小化活动桌面窗口之外的所有窗口（在第二个笔划时还原所有窗口）。</td></tr><tr><td>Windows 徽标键 + Shift + 向上键</td><td>将桌面窗口拉伸至屏幕顶部和底部。</td></tr><tr><td>Windows 徽标键 + Shift + 向下键</td><td>在垂直方向上还原/最小化活动桌面窗口，而宽度保持不变。</td></tr><tr><td>Windows 徽标键 + Shift + 向左键或向右键</td><td>将桌面上的应用或窗口从一台显示器移动至另一台显示器。</td></tr><tr><td>Windows 徽标键 + 空格键</td><td>切换输入语言和键盘布局。</td></tr><tr><td>Windows 徽标键 + Ctrl + 空格键</td><td>对之前选择的输入所做的更改。</td></tr><tr><td>Windows 徽标键 + Ctrl + Enter</td><td>打开“讲述人”。</td></tr><tr><td>Windows 徽标键 + 加号 (+)</td><td>打开“放大镜”。</td></tr><tr><td>Windows 徽标键 + 正斜杠 (/)</td><td>开始输入法复原流程。</td></tr><tr><td>Windows 徽标键 + Ctrl + V</td><td>打开肩式分接设备。</td></tr><tr><td>Windows 徽标键‌ + Ctrl + Shift + B</td><td><a href="https://support.microsoft.com/zh-cn/help/14106" target="_blank" rel="noopener">从空白屏幕或黑屏中唤醒</a></td></tr></tbody></table><h2 id="命令提示符键盘快捷方式"><a href="#命令提示符键盘快捷方式" class="headerlink" title="命令提示符键盘快捷方式"></a><a href="https://support.microsoft.com/" target="_blank" rel="noopener">命令提示符键盘快捷方式</a></h2><table><thead><tr><th>按该键</th><th>执行以下操作</th></tr></thead><tbody><tr><td>Ctrl + C（或 Ctrl + Insert）</td><td>复制选定文本。</td></tr><tr><td>Ctrl + V（或 Shift + Insert）</td><td>粘贴选定文本。</td></tr><tr><td>Ctrl + M</td><td>进入标记模式。</td></tr><tr><td>Alt + 所选择的键</td><td>开始在块模式下选择。</td></tr><tr><td>箭头键</td><td>按指定方向移动光标。</td></tr><tr><td>Page Up</td><td>将光标向上移动一个页面。</td></tr><tr><td>Page Down</td><td>将光标向下移动一个页面。</td></tr><tr><td>Ctrl + Home（标记模式）</td><td>将光标移动到缓冲区的起始处。</td></tr><tr><td>Ctrl + End（标记模式）</td><td>将光标移动到缓冲区的结尾处。</td></tr><tr><td>Ctrl + 向上键</td><td>在输出历史记录中上移一行。</td></tr><tr><td>Ctrl + 向下键</td><td>在输出历史记录中下移一行。</td></tr><tr><td>Ctrl + Home（历史记录导航）</td><td>如果命令行为空，则将视区移动到缓冲区顶部。否则，请删除命令行中光标左侧的所有字符。</td></tr><tr><td>Ctrl + End（历史记录导航）</td><td>如果命令行为空，则将视区移动到命令行。否则，请删除命令行中光标右侧的所有字符。</td></tr></tbody></table><h2 id="对话框键盘快捷方式"><a href="#对话框键盘快捷方式" class="headerlink" title="对话框键盘快捷方式"></a><a href="https://support.microsoft.com/" target="_blank" rel="noopener">对话框键盘快捷方式</a></h2><table><thead><tr><th>按该键</th><th>执行以下操作</th></tr></thead><tbody><tr><td>F4</td><td>显示活动列表中的项目。</td></tr><tr><td>Ctrl + Tab</td><td>在选项卡中向前移动。</td></tr><tr><td>Ctrl + Shift + Tab</td><td>在选项卡中向后移动。</td></tr><tr><td>Ctrl + 数字（数字 1–9）</td><td>移动到第 n 个选项卡。</td></tr><tr><td>Tab</td><td>在选项中向前移动。</td></tr><tr><td>Shift + Tab</td><td>在选项中向后移动。</td></tr><tr><td>Alt + 带下划线的字母</td><td>执行可与该字母结合使用的命令（或选择该选项）。</td></tr><tr><td>空格键</td><td>如果活动选项为复选框，则选择或清除复选框。</td></tr><tr><td>Backspace</td><td>如果在“另存为”或“打开”对话框中选择文件夹，则打开上一级别的文件夹。</td></tr><tr><td>箭头键</td><td>如果活动选项是一组选项按钮，请选择一个按钮。</td></tr></tbody></table><h2 id="文件资源管理器键盘快捷方式"><a href="#文件资源管理器键盘快捷方式" class="headerlink" title="文件资源管理器键盘快捷方式"></a><a href="https://support.microsoft.com/" target="_blank" rel="noopener">文件资源管理器键盘快捷方式</a></h2><table><thead><tr><th>按该键</th><th>执行以下操作</th></tr></thead><tbody><tr><td>Alt + D</td><td>选择地址栏。</td></tr><tr><td>Ctrl + E</td><td>选择搜索框。</td></tr><tr><td>Ctrl + F</td><td>选择搜索框。</td></tr><tr><td>Ctrl + N</td><td>打开新窗口。</td></tr><tr><td>Ctrl + W</td><td>关闭活动窗口。</td></tr><tr><td>Ctrl + 鼠标滚轮</td><td>更改文件和文件夹图标的大小和外观。</td></tr><tr><td>Ctrl + Shift + E</td><td>显示选定文件夹上的所有文件夹。</td></tr><tr><td>Ctrl + Shift + N</td><td>创建新文件夹。</td></tr><tr><td>Num Lock + 星号 (*)</td><td>显示选定文件夹下的所有子文件夹。</td></tr><tr><td>Num Lock + 加号 (+)</td><td>显示选定文件夹中的内容。</td></tr><tr><td>Num Lock + 减号 (-)</td><td>折叠选定文件夹。</td></tr><tr><td>Alt + P</td><td>显示预览面板。</td></tr><tr><td>Alt + Enter</td><td>打开选定项的“属性”对话框。</td></tr><tr><td>Alt + 向右键</td><td>查看下一个文件夹。</td></tr><tr><td>Alt + 向上键</td><td>查看该文件夹所在的文件夹。</td></tr><tr><td>Alt + 向左键</td><td>查看上一个文件夹。</td></tr><tr><td>Backspace</td><td>查看上一个文件夹。</td></tr><tr><td>向右键</td><td>显示当前选择内容（如果已折叠），或选择第一个子文件夹。</td></tr><tr><td>向左键</td><td>折叠当前选择内容（如果已展开），或选择该文件夹所在的文件夹。</td></tr><tr><td>End</td><td>显示活动窗口底部。</td></tr><tr><td>Home</td><td>显示活动窗口顶部。</td></tr><tr><td>F11</td><td>最大化或最小化活动窗口。</td></tr></tbody></table><h2 id="虚拟桌面键盘快捷方式"><a href="#虚拟桌面键盘快捷方式" class="headerlink" title="虚拟桌面键盘快捷方式"></a><a href="https://support.microsoft.com/" target="_blank" rel="noopener">虚拟桌面键盘快捷方式</a></h2><table><thead><tr><th>按该键</th><th>执行以下操作</th></tr></thead><tbody><tr><td>Windows 徽标键 + Tab</td><td>打开任务视图。</td></tr><tr><td>Windows 徽标键 + Ctrl + D</td><td>添加虚拟桌面。</td></tr><tr><td>Windows 徽标键 + Ctrl + 向右键</td><td>在你于右侧创建的虚拟桌面之间切换。</td></tr><tr><td>Windows 徽标键 + Ctrl + 向左键</td><td>在你于左侧创建的虚拟桌面之间切换。</td></tr><tr><td>Windows 徽标键 + Ctrl + F4</td><td>关闭你正在使用的虚拟桌面。</td></tr></tbody></table><h2 id="任务栏键盘快捷方式"><a href="#任务栏键盘快捷方式" class="headerlink" title="任务栏键盘快捷方式"></a><a href="https://support.microsoft.com/" target="_blank" rel="noopener">任务栏键盘快捷方式</a></h2><table><thead><tr><th>按该键</th><th>执行以下操作</th></tr></thead><tbody><tr><td>Shift + 单击任务栏按钮</td><td>打开应用或快速打开另一个应用实例。</td></tr><tr><td>Ctrl + Shift + 单击任务栏按钮</td><td>以管理员身份打开应用。</td></tr><tr><td>Shift + 右键单击任务栏按钮</td><td>显示应用的窗口菜单。</td></tr><tr><td>Shift + 右键单击分组任务栏按钮</td><td>显示组的窗口菜单。</td></tr><tr><td>Ctrl + 单击分组任务栏按钮</td><td>循环浏览组的窗口。</td></tr></tbody></table><h2 id="设置键盘快捷方式"><a href="#设置键盘快捷方式" class="headerlink" title="设置键盘快捷方式"></a><a href="https://support.microsoft.com/" target="_blank" rel="noopener">设置键盘快捷方式</a></h2><table><thead><tr><th>按该键</th><th>执行以下操作</th></tr></thead><tbody><tr><td>Windows 徽标键 + I</td><td>打开设置。</td></tr><tr><td>Backspace</td><td>返回到设置主页。</td></tr><tr><td>使用搜索框在任何页面上键入</td><td>搜索设置。</td></tr></tbody></table><p>上次更新时间：2020年1月16日</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;其他键盘快捷方式&quot;&gt;&lt;a href=&quot;#其他键盘快捷方式&quot; class=&quot;headerlink&quot; title=&quot;其他键盘快捷方式&quot;&gt;&lt;/a&gt;其他键盘快捷方式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://support.microsoft.com/zh-cn/help/13805&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;应用中的键盘快捷方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://support.microsoft.com/zh-cn/help/13810&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;用于辅助功能的 Windows 键盘快捷方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://support.microsoft.com/zh-cn/help/13813&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Microsoft Surface Hub 键盘快捷方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://support.microsoft.com/zh-cn/help/13781&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;适用于手机的 Continuum 中的键盘快捷方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://zystrivego.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="win10" scheme="https://zystrivego.github.io/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>高级搜索</title>
    <link href="https://zystrivego.github.io/2020/05/28/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/"/>
    <id>https://zystrivego.github.io/2020/05/28/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2/</id>
    <published>2020-05-28T14:20:10.000Z</published>
    <updated>2020-09-20T15:35:11.932Z</updated>
    
    <content type="html"><![CDATA[<p>Google搜索运算符是特殊字符和命令（有时称为“高级运算符”），它们扩展了常规文本搜索的功能。搜索运算符对于从内容研究到技术SEO审核的所有工作都非常有用。</p><a id="more"></a><h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><table><thead><tr><th>“ “</th><th>精确匹配</th></tr></thead><tbody><tr><td>OR</td><td><strong><a href="https://www.google.com/search?q=tesla+OR+edison" target="_blank" rel="noopener">tesla OR edison</a></strong> 逻辑或搜索大写，默认是与操作</td></tr><tr><td>|</td><td><strong><a href="https://www.google.com/search?q=tesla+|+edison" target="_blank" rel="noopener">tesla | edison</a></strong>  同上</td></tr><tr><td>( )</td><td><strong><a href="https://www.google.com/search?q=(tesla+OR+edison)+alternating+current" target="_blank" rel="noopener">(tesla OR edison) alternating current</a></strong> 使用括号将运算符分组并控制其执行顺序</td></tr><tr><td>-</td><td><strong><a href="https://www.google.com/search?q=tesla+-motors" target="_blank" rel="noopener">tesla -motors</a></strong> 减号排除</td></tr><tr><td>*</td><td><strong><a href="https://www.google.com/search?q=tesla+" target="_blank" rel="noopener"rock+*+roll"">tesla “rock * roll”</a></strong> 通配符</td></tr><tr><td>#..#</td><td><strong><a href="https://www.google.com/search?q=tesla+announcement+2015..2017" target="_blank" rel="noopener">tesla announcement 2015..2017</a></strong> 使用（..）两侧带有数字以匹配该数字范围内的任何整数。</td></tr><tr><td>in</td><td><strong><a href="https://www.google.com/search?q=250+kph+in+mph" target="_blank" rel="noopener">250 kph in mph</a></strong> 单位转换</td></tr></tbody></table><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>修改搜索的特殊命令，可能需要其他参数（例如域名）。通常用于缩小搜索范围并深入研究结果。</p><table><thead><tr><th>intitle:</th><th><strong><a href="https://www.google.com/search?q=intitle:" target="_blank" rel="noopener"tesla+vs+edison"">intitle:”tesla vs edison”</a></strong> 仅在页面标题中搜索单词或短语，全匹配</th></tr></thead><tbody><tr><td>allintitle:</td><td><strong><a href="https://www.google.com/search?q=allintitle:+tesla+vs+edison" target="_blank" rel="noopener">allintitle: tesla vs edison</a></strong> 同多个intitle</td></tr><tr><td>inurl:</td><td><strong><a href="https://www.google.com/search?q=tesla+announcements+inurl:2016" target="_blank" rel="noopener">tesla announcements inurl:2016</a></strong> 在url中搜索</td></tr><tr><td>allinurl:</td><td><strong><a href="https://www.google.com/search?q=allinurl:+amazon+field-keywords+nikon" target="_blank" rel="noopener">allinurl: amazon field-keywords nikon</a></strong> 同多个inurl</td></tr><tr><td>intext:</td><td><strong><a href="https://www.google.com/search?q=intext:" target="_blank" rel="noopener"orbi+vs+eero+vs+google+wifi"">intext:”orbi vs eero vs google wifi”</a></strong> 在中文中搜索</td></tr><tr><td>allintext:</td><td><strong><a href="https://www.google.com/search?q=allintext:+orbi+eero+google+wifi" target="_blank" rel="noopener">allintext: orbi eero google wifi</a></strong> 同多个intext</td></tr><tr><td>filetype:</td><td><strong><a href="https://www.google.com/search?q=" target="_blank" rel="noopener"tesla+announcements"+filetype:pdf">“tesla announcements” filetype:pdf</a></strong> 匹配文件类型</td></tr><tr><td>related:</td><td><strong><a href="https://www.google.com/search?q=related:nytimes.com" target="_blank" rel="noopener">related:nytimes.com</a></strong> 返回与目标域相关的站点。仅适用于较大的域。</td></tr><tr><td>AROUND(X)</td><td><strong><a href="https://www.google.com/search?q=tesla+AROUND(3)+edison" target="_blank" rel="noopener">tesla AROUND(3) edison</a></strong> 返回两个术语/短语在（X）个单词以内的结果。</td></tr></tbody></table><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="1-组合"><a href="#1-组合" class="headerlink" title="1.组合"></a>1.组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;nikola tesla&quot; intitle:&quot;top 5..10 facts&quot; -site:youtube.com inurl:2015</span><br></pre></td></tr></table></figure><p>此搜索将返回所有提及“ Nikola Tesla”（完全匹配），标题中带有“ Top（X）facts”的页面，其中X介于5到10之间，不在YouTube.com上，并且具有“ 2015年” ”中的某处。</p><h2 id="2-查抄窃的内容"><a href="#2-查抄窃的内容" class="headerlink" title="2. 查抄窃的内容"></a>2. 查抄窃的内容</h2><p>试图找出您的内容是否独特或有人someone窃您吗？在您的文本中使用唯一的短语，在“ intext：”运算符后将其放在引号（完全匹配）中，并使用“ -site：”排除您自己的网站…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intext:&quot;they were frolicking in our entrails&quot; -site:moz.com</span><br></pre></td></tr></table></figure><h2 id="3-审核您的HTTP-gt-HTTPS过渡"><a href="#3-审核您的HTTP-gt-HTTPS过渡" class="headerlink" title="3.审核您的HTTP-&gt; HTTPS过渡"></a>3.审核您的HTTP-&gt; HTTPS过渡</h2><p>将站点从HTTP切换到HTTPS可能具有挑战性。通过查看Google为每种类型的页面编制了多少索引来仔细检查您的进度。在根域上使用“ site：”运算符，然后使用“ -inurl：”排除HTTPS页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:lenovo.com -inurl:https</span><br></pre></td></tr></table></figure><p>这将帮助您查找任何散乱的内容或查找Google可能没有重新抓取的页面。</p><p><strong>参考地址</strong></p><p><a href="https://moz.com/learn/seo/search-operators" target="_blank" rel="noopener">Google Search Operators [2020 SEO] - Moz</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google搜索运算符是特殊字符和命令（有时称为“高级运算符”），它们扩展了常规文本搜索的功能。搜索运算符对于从内容研究到技术SEO审核的所有工作都非常有用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://zystrivego.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="seo" scheme="https://zystrivego.github.io/tags/seo/"/>
    
  </entry>
  
  <entry>
    <title>SaaS vs PaaS vs IaaS: What’s The Difference and How To Choose</title>
    <link href="https://zystrivego.github.io/2020/05/27/SaaS-vs-PaaS-vs-IaaS-What%E2%80%99s-The-Difference-and-How-To-Choose/"/>
    <id>https://zystrivego.github.io/2020/05/27/SaaS-vs-PaaS-vs-IaaS-What%E2%80%99s-The-Difference-and-How-To-Choose/</id>
    <published>2020-05-27T03:26:07.000Z</published>
    <updated>2020-05-27T07:27:19.399Z</updated>
    
    <content type="html"><![CDATA[<p>从小型企业到全球化企业，云计算都是一个热门话题，但它仍然是一个涵盖了许多在线领域的宽泛概念。 当您开始考虑将您的业务转移到云计算时，无论是为了应用程序还是基础设施部署，理解各种云服务的区别和优势比以往任何时候都更为重要。</p><a id="more"></a><p>通常有三种云服务模型可供比较: <strong>软件即服务(Software as a Service，SaaS)</strong>、<strong>平台即服务(Platform as a Service，PaaS)</strong>和<strong>基础设施即服务(Infrastructure as a Service，IaaS)</strong>。 这些方法都有自己的优点，也有不同之处，因此有必要了解 SaaS、 PaaS 和 IaaS 之间的差异，以便知道如何为您的组织最佳地选择其中之一。</p><h2 id="主要差异摘要"><a href="#主要差异摘要" class="headerlink" title="主要差异摘要"></a>主要差异摘要</h2><p><img src="https://blogs.bmc.com/wp-content/uploads/2017/09/saas-vs-paas-vs-iaas-810x754.png" alt=""></p><h2 id="Saas、-PaaS-和-IaaS-的常见例子"><a href="#Saas、-PaaS-和-IaaS-的常见例子" class="headerlink" title="Saas、 PaaS 和 IaaS 的常见例子"></a>Saas、 PaaS 和 IaaS 的常见例子</h2><table><thead><tr><th>平台类型</th><th><strong>常见例子</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td>Google Apps, Dropbox, Salesforce, Cisco WebEx, Concur, GoToMeeting</td></tr><tr><td><strong>PaaS</strong></td><td>AWS Elastic Beanstalk, Windows Azure, Heroku, Force.com, Google App Engine, Apache Stratos, OpenShift</td></tr><tr><td><strong>IaaS</strong></td><td>DigitalOcean, Linode, Rackspace, Amazon Web Services (AWS), Cisco Metapod, Microsoft Azure, Google Compute Engine (GCE)</td></tr></tbody></table><h2 id="SaaS：软件即服务"><a href="#SaaS：软件即服务" class="headerlink" title="SaaS：软件即服务"></a>SaaS：软件即服务</h2><p>软件即服务，也被称为云应用服务，是云市场上最常用的商业选择。 Saas 利用互联网向用户交付由第三方供应商管理的应用程序。 大多数 SaaS 应用程序直接通过 web 浏览器运行，这意味着它们不需要在客户端进行任何下载或安装。</p><h3 id="交付"><a href="#交付" class="headerlink" title="交付"></a>交付</h3><p>由于其 web 交付模式，SaaS 无需 IT 人员在每台计算机上下载和安装应用程序。 通过 SaaS，供应商可以管理所有潜在的技术问题，如数据、中间件、服务器和存储，从而简化业务的维护和支持。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>Saas 为员工和公司提供了许多优势，因为它大大减少了安装、管理和升级软件等繁琐任务所花费的时间和金钱。 这样可以为技术人员腾出大量时间，用于处理组织内更为紧迫的事务和问题。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>有几种方法可以帮助您确定什么时候使用 SaaS:</p><ul><li>从中心位置管理</li><li>托管在远程服务器上</li><li>可通过互联网访问</li><li>用户不负责硬件或软件更新</li></ul><h3 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h3><p>在某些情况下 SaaS 可能是最有益的选择，包括:</p><ul><li>初创公司或小公司需要快速推出电子商务，没有时间处理服务器问题或软件</li><li>需要快速、简单和负担得起的协作的短期项目</li><li>不需要经常使用的应用程序，如税务软件</li><li>同时需要 web 和移动访问的应用程序</li></ul><h3 id="局限性和担忧"><a href="#局限性和担忧" class="headerlink" title="局限性和担忧"></a>局限性和担忧</h3><ul><li><strong>互操作性。</strong>如果SaaS应用程序不旨在遵循开放式集成标准，则与现有应用程序和服务的集成可能成为主要问题。在这种情况下，组织可能需要设计自己的集成系统或减少对SaaS服务的依赖性，而这并非总是可能的。</li><li><strong>供应商锁定。</strong>供应商可能使加入服务变得容易，而退出服务却变得困难。例如，数据可能无法在技术上或成本效益上跨其他供应商的SaaS应用程序移植，而不会招致大量成本或内部工程返工。并非每个供应商都遵循标准的API，协议和工具，但是某些业务任务可能需要这些功能。</li><li><strong>缺乏集成支持。</strong>许多组织需要与本地应用程序，数据和服务进行深度集成。SaaS供应商在这方面可能会提供有限的支持，从而迫使组织在设计和管理集成方面投入内部资源。集成的复杂性可能进一步限制SaaS应用程序或其他依赖服务的使用方式。</li><li><strong>数据安全。</strong>为了执行必要的软件功能，可能必须将大量数据交换到SaaS应用程序的后端数据中心。将敏感的业务信息转移到基于公共云的SaaS服务可能会导致安全性和合规性受损，此外还需要迁移大量数据工作负载。</li><li><strong>定制化。</strong>SaaS应用程序提供最少的自定义功能。由于不存在一种千篇一律的解决方案，因此用户可能仅限于供应商提供的特定功能，性能和集成。相反，一些软件开发工具包（SDK）附带的本地解决方案提供了高度的定制选项。</li><li><strong>缺乏控制。</strong>SaaS解决方案涉及将控制权移交给第三方服务提供商。这些控件不仅限于软件-在版本，更新或外观方面-而且还包括数据和管理。因此，客户可能需要重新定义其数据安全性和治理模型，以适应SaaS服务的特性和功能。</li><li><strong>功能限制。</strong>由于SaaS应用程序通常以标准化形式出现，因此功能的选择可能会折衷于与安全性，成本，性能或其他组织策略的权衡。此外，供应商的锁定，成本或安全性问题可能意味着将来无法切换供应商或服务来满足新功能要求。</li><li><strong>性能和停机时间。</strong>由于供应商控制和管理SaaS服务，因此您的客户现在依赖供应商来维护服务的安全性和性能。尽管有适当的服务级别协议（SLA）保护，但计划内和计划外的维护，网络攻击或网络问题仍可能影响SaaS应用程序的性能。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>这些是SaaS的几个流行示例，包括：<a href="https://gsuite.google.com/" target="_blank" rel="noopener">Google GSuite</a>（应用程序），<a href="https://www.dropbox.com/" target="_blank" rel="noopener">Dropbox</a>，<a href="https://www.salesforce.com/" target="_blank" rel="noopener">Salesforce</a>，<a href="https://www.webex.com/" target="_blank" rel="noopener">Cisco WebEx</a>，<a href="https://www.concur.com/" target="_blank" rel="noopener">SAP Concur</a>和<a href="https://www.gotomeeting.com/" target="_blank" rel="noopener">GoToMeeting</a>。</p><h2 id="PaaS：平台即服务"><a href="#PaaS：平台即服务" class="headerlink" title="PaaS：平台即服务"></a>PaaS：平台即服务</h2><p>云平台服务（也称为平台即服务（PaaS））为某些软件提供云组件，同时主要用于应用程序。PaaS为开发人员提供了一个框架，开发人员可以在此框架上建立并使用该框架来创建自定义应用程序。所有服务器，存储和网络都可以由企业或第三方提供商管理，而开发人员可以维护应用程序的管理。</p><h3 id="交付-1"><a href="#交付-1" class="headerlink" title="交付"></a>交付</h3><p>PaaS的交付模型与SaaS相似，不同的是PaaS提供了软件创建平台，而不是通过Internet交付软件。该平台通过Web交付，使开发人员可以自由地专注于构建软件，而不必担心操作系统，软件更新，存储或基础架构。</p><p>PaaS允许企业设计和创建内置于带有特殊软件组件的PaaS中的应用程序。这些应用程序有时被称为中间件，由于具有某些云特性，因此具有可伸缩性和高可用性。</p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>无论您的公司规模大小，使用PaaS都有许多优势，包括：</p><ul><li>简单，经济高效的应用开发和部署</li><li>可扩展</li><li>高度可用</li><li>开发人员可以自定义应用程序，而无需维护软件</li><li>大大减少了所需的编码量</li><li>商业政策自动化</li><li>轻松迁移到混合模型</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>PaaS具有许多将其定义为云服务的特征，包括：</p><ul><li>建立在虚拟化技术之上，因此随着业务的变化，可以轻松地按比例放大或缩小资源</li><li>提供各种服务以协助开发，测试和部署应用程序</li><li>通过同一个开发应用程序可被众多用户访问</li><li>集成Web服务和数据库</li></ul><h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>在某些情况下，使用PaaS是有益的，有时甚至是必要的。例如，当多个开发人员在同一个开发项目上工作时，PaaS可以简化工作流程。如果必须包括其他供应商，PaaS可以为整个过程提供极大的速度和灵活性。如果您需要创建定制的应用程序，则PaaS尤其有用。如果您正在快速开发或部署应用程序，则该云服务还可以大大降低成本，并且可以简化一些挑战。</p><h3 id="局限性和担忧-1"><a href="#局限性和担忧-1" class="headerlink" title="局限性和担忧"></a>局限性和担忧</h3><ul><li><strong>数据安全。</strong>企业可以使用PaaS解决方案来运行自己的应用程序和服务，但是驻留在第三方，由供应商控制的第三方云服务器中的数据带来了安全风险和担忧。您的安全选项可能会受到限制，因为客户可能无法使用特定的托管策略来部署服务。</li><li><strong>整合。</strong>连接存储在现场数据中心或非内部云中的数据的复杂性增加，这可能会影响PaaS产品可以采用哪些应用程序和服务。特别是当并非旧IT系统的每个组件都不是为云构建的时，与现有服务和基础架构的集成可能是一个挑战。</li><li><strong>供应商锁定。</strong>决定特定PaaS解决方案决策的业务和技术要求将来可能不再适用。如果供应商未设置方便的迁移策略，则在不影响业务的情况下可能无法切换到其他PaaS选项。</li><li><strong>遗留系统的定制。</strong>PaaS可能不是现有遗留应用程序和服务的即插即用解决方案。相反，旧系统要与PaaS服务一起使用可能需要进行一些自定义和配置更改。最终的定制可能导致复杂的IT系统，从而可能完全限制PaaS投资的价值。</li><li><strong>运行时问题。</strong>除了与特定应用程序和服务相关的限制外，PaaS解决方案可能未针对您选择的语言和框架进行优化。特定的框架版本可能不可用，或者无法与PaaS服务一起最佳地运行。客户可能无法使用该平台开发自定义依赖项。</li><li><strong>操作限制。</strong>具有管理自动化工作流程的自定义云操作可能不适用于PaaS解决方案，因为该平台往往会限制最终用户的操作能力。尽管这旨在减轻最终用户的操作负担，但是操作控制的丢失可能会影响PaaS解决方案的管理，设置和操作方式。</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>PaaS的流行示例包括<a href="https://aws.amazon.com/elasticbeanstalk/" target="_blank" rel="noopener">AWS Elastic Beanstalk</a>，<a href="https://azure.microsoft.com/en-us/free/windows-server-on-azure/" target="_blank" rel="noopener">Windows Azure</a>，<a href="https://www.heroku.com/" target="_blank" rel="noopener">Heroku</a>，<a href="https://developer.salesforce.com/platform/force.com" target="_blank" rel="noopener">Force.com</a>，<a href="https://cloud.google.com/appengine/" target="_blank" rel="noopener">Google App Engine</a>和<a href="https://www.openshift.com/" target="_blank" rel="noopener">OpenShift</a>。</p><h2 id="IaaS：基础架构即服务"><a href="#IaaS：基础架构即服务" class="headerlink" title="IaaS：基础架构即服务"></a>IaaS：基础架构即服务</h2><p>云基础架构服务（称为基础架构即服务（IaaS））由高度可扩展的自动化计算资源组成。IaaS是完全<a href="https://www.bmc.com/blogs/self-service-thrives-clouds/" target="_blank" rel="noopener">自助服务，</a>用于访问和监视计算机，网络，存储和其他服务。IaaS允许企业按需和按需购买资源，而不必直接购买硬件。</p><h3 id="交付-2"><a href="#交付-2" class="headerlink" title="交付"></a>交付</h3><p>IaaS通过虚拟化技术提供了包括服务器，网络，操作系统和存储在内的云计算基础架构。这些云服务器通常通过仪表板或API提供给组织，从而使IaaS客户端可以完全控制整个基础架构。IaaS提供与传统数据中心相同的技术和功能，而无需物理维护或管理所有数据中心。IaaS客户端仍然可以直接访问其服务器和存储，但是它们都是通过云中的“虚拟数据中心”外包的。</p><p>与SaaS或PaaS相对，IaaS客户端负责管理各个方面，例如应用程序，运行时，操作系统，中间件和数据。但是，IaaS的提供商管理服务器，硬盘驱动器，网络，虚拟化和存储。一些提供商甚至提供超出虚拟化层的更多服务，例如数据库或消息队列。</p><h3 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h3><ul><li>最灵活的云计算模型</li><li>易于自动化存储、网络、服务器和处理能力的部署</li><li>硬件购买可以基于消费</li><li>客户端保留对其基础设施的完全控制</li><li>可以根据需要购买资源</li><li>高度可扩展性</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>定义 IaaS 的特征包括:</p><ul><li>资源可以作为服务使用</li><li>成本取决于消费量</li><li>服务是高度可扩展的</li><li>一个硬件上有多个用户</li><li>组织保持对基础设施的完全控制</li><li>动态的和灵活的</li></ul><h3 id="何时使用-1"><a href="#何时使用-1" class="headerlink" title="何时使用"></a>何时使用</h3><p>就像SaaS和PaaS一样，在某些情况下IaaS最有利。</p><p>初创企业和小型公司可能更喜欢IaaS，以避免花费时间和金钱来购买和创建硬件和软件。较大的公司可能希望保留对其应用程序和基础结构的完全控制权，但是他们只想购买他们实际消费或需要的东西。像IaaS的可扩展性一样，公司经历了快速的增长，随着需求的发展，他们可以轻松地更换特定的硬件和软件。每当您不确定新应用程序的需求时，IaaS都会提供足够的灵活性和可伸缩性。</p><h3 id="局限性和担忧-2"><a href="#局限性和担忧-2" class="headerlink" title="局限性和担忧"></a>局限性和担忧</h3><p>与SaaS和PaaS模型相关的许多限制（例如数据安全性，成本超支，供应商锁定和自定义问题）也适用于IaaS模型。IaaS的特殊限制包括：</p><ul><li><strong>安全。</strong>当客户控制应用程序，数据，中间件和OS平台时，仍然可以从主机或其他虚拟机（VM）发出安全威胁。内部威胁或系统漏洞可能会将主机基础结构和VM之间的数据通信暴露给未经授权的实体。</li><li><strong>在云中运行的旧系统。</strong>尽管客户可以在云中运行旧版应用程序，但基础架构可能无法设计为提供特定控件以保护旧版应用程序。在将旧版应用程序迁移到云之前，可能需要对旧版应用程序进行较小的增强，这可能会导致新的安全问题，除非对IaaS系统中的安全性和性能进行了充分的测试。</li><li><strong>内部资源和培训。</strong>劳动力可能需要其他资源和培训，以学习如何有效管理基础架构。客户将负责数据安全性，备份和业务连续性。但是，由于对基础架构的控制不足，如果没有足够的内部培训和可用资源，则可能难以对资源进行监视和管理。</li><li><strong>多租户安全性。</strong>由于硬件资源是在可用时在用户之间动态分配的，因此要求供应商确保其他客户不能访问以前的客户存储在存储资产中的数据。同样，客户必须依靠供应商来确保VM在多租户云体系结构中得到充分隔离。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>IaaS的流行示例包括<a href="https://www.digitalocean.com/" target="_blank" rel="noopener">DigitalOcean</a>，<a href="https://www.linode.com/" target="_blank" rel="noopener">Linode</a>，<a href="https://www.rackspace.com/" target="_blank" rel="noopener">Rackspace</a>，<a href="https://aws.amazon.com/" target="_blank" rel="noopener">Amazon Web Services（AWS）</a>，<a href="https://www.cisco.com/c/en/us/products/cloud-systems-management/metacloud/index.html" target="_blank" rel="noopener">Cisco Metacloud</a>，<a href="https://azure.microsoft.com/en-us/" target="_blank" rel="noopener">Microsoft Azure</a>和<a href="https://cloud.google.com/compute/" target="_blank" rel="noopener">Google Compute Engine（GCE）</a>。</p><h2 id="SaaS-vs-PaaS-vs-IaaS"><a href="#SaaS-vs-PaaS-vs-IaaS" class="headerlink" title="SaaS vs PaaS vs IaaS"></a>SaaS vs PaaS vs IaaS</h2><p>每个云模型都提供特定的功能，对于您的组织而言，了解差异至关重要。无论您是需要基于云的软件作为存储选项，还是需要一个平滑的平台来创建自定义的应用程序，或者无需物理维护即可完全控制整个基础架构，都可以使用云服务。无论您选择哪种选择，<a href="https://www.bmc.com/blogs/new-multi-cloud-world-means/" target="_blank" rel="noopener">迁移到云</a>都是业务和技术的未来。</p><h2 id="XaaS：Everything-as-a-Service"><a href="#XaaS：Everything-as-a-Service" class="headerlink" title="XaaS：Everything as a Service"></a>XaaS：Everything as a Service</h2><p>您可能会在世界上更经常看到的一个术语是XaaS或“一切即服务”。XaaS是指完全由客户控制的高度个性化，响应迅速，数据驱动的产品和产品，以及它们通过日常物联网驱动的源（例如手机和恒温器）提供的数据。通过使用通过云生成的数据，企业可以更快地进行创新，加深他们的客户关系，并在最初购买产品之后维持销售。XaaS是<a href="https://www.bmc.com/corporate/autonomous-digital-enterprise.html" target="_blank" rel="noopener">自治数字企业</a>的关键推动者。</p><blockquote><p><a href="https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/" target="_blank" rel="noopener">转载地址</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从小型企业到全球化企业，云计算都是一个热门话题，但它仍然是一个涵盖了许多在线领域的宽泛概念。 当您开始考虑将您的业务转移到云计算时，无论是为了应用程序还是基础设施部署，理解各种云服务的区别和优势比以往任何时候都更为重要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="百科" scheme="https://zystrivego.github.io/categories/%E7%99%BE%E7%A7%91/"/>
    
    
      <category term="aaS" scheme="https://zystrivego.github.io/tags/aaS/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://zystrivego.github.io/2020/05/27/docker/"/>
    <id>https://zystrivego.github.io/2020/05/27/docker/</id>
    <published>2020-05-27T02:52:05.000Z</published>
    <updated>2020-05-27T10:15:11.595Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是容器？一种标准化的软件单位。<br>容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化了操作系统，而不是硬件。容器更加便携和高效。</p></blockquote><a id="more"></a><p><strong>容器</strong>是应用层的抽象，用于将代码和依赖项打包在一起。多个容器可以在同一台计算机上运行，并与其他容器共享 OS 内核，每个容器在用户空间中作为独立进程运行。容器占用的空间比 VM 少（容器映像通常大小为数十 MB），可以处理更多的应用程序，并且需要更少的 VM 和操作系统。</p><p><strong>虚拟机</strong> （VM） 是物理硬件的抽象，将一台服务器转换为多台服务器。虚拟机管理程序允许在一台计算机上运行多个 VM。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本-占用数十个 GB。</p><p><strong>镜像（<code>Image</code>）和容器（<code>Container</code>）</strong>的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><h1 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">学习地址</a></h1><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a><a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">安装步骤</a></h1><h2 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a>设置仓库</h2><p>Install the <code>yum-utils</code> package (which provides the <code>yum-config-manager</code> utility) and set up the <strong>stable</strong> repository.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="安装-docker-engine"><a href="#安装-docker-engine" class="headerlink" title="安装 docker engine"></a>安装 docker engine</h2><ol><li>Install the <em>latest version</em> of Docker Engine and containerd</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="2"><li>Start Docker.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h1 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h1><p>从刚才的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mynginx</span><br><span class="line">$ cd mynginx</span><br><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a><strong>FROM 指定基础镜像</strong></h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="noopener"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="noopener"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="noopener"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/" target="_blank" rel="noopener"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd" target="_blank" rel="noopener"><code>etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a><strong>RUN 执行命令</strong></h2><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN mkdir -p &#x2F;usr&#x2F;src&#x2F;redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1</span><br><span class="line">RUN make -C &#x2F;usr&#x2F;src&#x2F;redis</span><br><span class="line">RUN make -C &#x2F;usr&#x2F;src&#x2F;redis install</span><br></pre></td></tr></table></figure><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN buildDeps&#x3D;&#39;gcc libc6-dev make wget&#39; \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1 \</span><br><span class="line">    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis install \</span><br><span class="line">    &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a><strong>构建镜像</strong></h2><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line"> ---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br><span class="line"> ---&gt; Running in 9cdc27646c7b</span><br><span class="line"> ---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径&#x2F;URL&#x2F;-&gt;</span><br></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a><strong>镜像构建上下文（Context）</strong></h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY .&#x2F;package.json &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a><strong>其它 <code>docker build</code> 的用法</strong></h2><h3 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a><strong>直接用 Git repo 进行构建</strong></h3><p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker build https:&#x2F;&#x2F;github.com&#x2F;twang2218&#x2F;gitlab-ce-zh.git#:11.1</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab&#x2F;gitlab-ce:11.1.0-ce.0</span><br><span class="line">11.1.0-ce.0: Pulling from gitlab&#x2F;gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这行命令指定了构建所需的 Git repo，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/11.1/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><h3 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a><strong>用给定的 tar 压缩包构建</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http:&#x2F;&#x2F;server&#x2F;context.tar.gz</span><br></pre></td></tr></table></figure><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><h3 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a><strong>从标准输入中读取 Dockerfile 进行构建</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p><h3 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a><strong>从标准输入中读取上下文压缩包进行构建</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;什么是容器？一种标准化的软件单位。&lt;br&gt;容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化了操作系统，而不是硬件。容器更加便携和高效。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://zystrivego.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="https://zystrivego.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Shiro</title>
    <link href="https://zystrivego.github.io/2020/05/27/Shiro/"/>
    <id>https://zystrivego.github.io/2020/05/27/Shiro/</id>
    <published>2020-05-27T02:50:55.000Z</published>
    <updated>2020-05-27T02:50:55.727Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p><strong>Apache Shiro™</strong> is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.</p><p>Welcome to <a href="http://shiro.apache.org/index.html" target="_blank" rel="noopener">Shiro!</a></p>          </div><a id="more"></a><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a><a href="http://shiro.apache.org/introduction.html#apache-shiro-features" target="_blank" rel="noopener">Features</a></h2><p>Apache Shiro is a comprehensive application security framework with many features. The following diagram shows where Shiro focuses its energy, and this reference manual will be organized similarly:</p><p><img src="http://shiro.apache.org/assets/images/ShiroFeatures.png" alt="img"></p><p>Shiro targets what the Shiro development team calls “the four cornerstones of application security” - Authentication, Authorization, Session Management, and Cryptography:</p><ul><li><strong>Authentication:</strong> Sometimes referred to as ‘login’, this is the act of proving a user is who they say they are.</li><li><strong>Authorization:</strong> The process of access control, i.e. determining ‘who’ has access to ‘what’.</li><li><strong>Session Management:</strong> Managing user-specific sessions, even in non-web or EJB applications.</li><li><strong>Cryptography:</strong> Keeping data secure using cryptographic algorithms while still being easy to use.</li></ul><p>There are also additional features to support and reinforce these concerns in different application environments, especially:</p><ul><li>Web Support: Shiro’s web support APIs help easily secure web applications.</li><li>Caching: Caching is a first-tier citizen in Apache Shiro’s API to ensure that security operations remain fast and efficient.</li><li>Concurrency: Apache Shiro supports multi-threaded applications with its concurrency features.</li><li>Testing: Test support exists to help you write unit and integration tests and ensure your code will be secured as expected.</li><li>“Run As”: A feature that allows users to assume the identity of another user (if they are allowed), sometimes useful in administrative scenarios.</li><li>“Remember Me”: Remember users’ identities across sessions so they only need to log in when mandatory.</li></ul><h2 id="High-Level-Overview"><a href="#High-Level-Overview" class="headerlink" title="High-Level Overview"></a>High-Level Overview</h2><p>At the highest conceptual level, Shiro’s architecture has 3 primary concepts: the <code>Subject</code>, <code>SecurityManager</code> and <code>Realms</code>. The following diagram is a high-level overview of how these components interact, and we’ll cover each concept below:</p><p><img src="http://shiro.apache.org/assets/images/ShiroBasicArchitecture.png" alt="img"></p><ul><li><p><strong>Subject</strong>: As we’ve mentioned in our <a href="http://shiro.apache.org/tutorial.html" target="_blank" rel="noopener">Tutorial</a>, the <code>Subject</code> is essentially a security specific ‘view’ of the the currently executing user. Whereas the word ‘User’ often implies a human being, a <code>Subject</code> can be a person, but it could also represent a 3rd-party service, daemon account, cron job, or anything similar - basically anything that is currently interacting with the software.</p><p><code>Subject</code> instances are all bound to (and require) a <code>SecurityManager</code>. When you interact with a <code>Subject</code>, those interactions translate to subject-specific interactions with the <code>SecurityManager</code>.</p></li><li><p><strong>SecurityManager</strong>: The <code>SecurityManager</code> is the heart of Shiro’s architecture and acts as a sort of ’umbrella’ object that coordinates its internal security components that together form an object graph. However, once the SecurityManager and its internal object graph is configured for an application, it is usually left alone and application developers spend almost all of their time with the <code>Subject</code> API.</p><p>We will talk about the <code>SecurityManager</code> in detail later on, but it is important to realize that when you interact with a <code>Subject</code>, it is really the <code>SecurityManager</code> behind the scenes that does all the heavy lifting for any <code>Subject</code> security operation. This is reflected in the basic flow diagram above.</p></li><li><p><strong>Realms</strong>: Realms act as the ‘bridge’ or ‘connector’ between Shiro and your application’s security data. When it comes time to actually interact with security-related data like user accounts to perform authentication (login) and authorization (access control), Shiro looks up many of these things from one or more Realms configured for an application.</p><p>In this sense a Realm is essentially a security-specific <a href="https://en.wikipedia.org/wiki/Data_access_object" target="_blank" rel="noopener">DAO</a>: it encapsulates connection details for data sources and makes the associated data available to Shiro as needed. When configuring Shiro, you must specify at least one Realm to use for authentication and/or authorization. The <code>SecurityManager</code> may be configured with multiple Realms, but at least one is required.</p><p>Shiro provides out-of-the-box Realms to connect to a number of security data sources (aka directories) such as LDAP, relational databases (JDBC), text configuration sources like INI and properties files, and more. You can plug-in your own Realm implementations to represent custom data sources if the default Realms do not meet your needs.</p><p>Like other internal components, the Shiro <code>SecurityManager</code> manages how Realms are used to acquire security and identity data to be represented as <code>Subject</code> instances.</p></li></ul><h2 id="Detailed-Architecture"><a href="#Detailed-Architecture" class="headerlink" title="Detailed Architecture"></a><a href="http://shiro.apache.org/architecture.html#detailed-architecture" target="_blank" rel="noopener">Detailed Architecture</a></h2><p>The following diagram shows Shiro’s core architectural concepts followed by short summaries of each:</p><p><img src="http://shiro.apache.org/assets/images/ShiroArchitecture.png" alt="img"></p><ul><li><strong>Subject</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html" target="_blank" rel="noopener"><code>org.apache.shiro.subject.Subject</code></a>)<br>A security-specific ‘view’ of the entity (user, 3rd-party service, cron job, etc) currently interacting with the software.</li><li><strong>SecurityManager</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/mgt/SecurityManager.html" target="_blank" rel="noopener">org.apache.shiro.mgt.SecurityManager</a>)<br>As mentioned above, the <code>SecurityManager</code> is the heart of Shiro’s architecture. It is mostly an ‘umbrella’ object that coordinates its managed components to ensure they work smoothly together. It also manages Shiro’s view of every application user, so it knows how to perform security operations per user.</li><li><strong>Authenticator</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/Authenticator.html" target="_blank" rel="noopener">org.apache.shiro.authc.Authenticator</a>)<br>The <code>Authenticator</code> is the component that is responsible for executing and reacting to authentication (log-in) attempts by users. When a user tries to log-in, that logic is executed by the <code>Authenticator</code>. The <code>Authenticator</code> knows how to coordinate with one or more <code>Realms</code> that store relevant user/account information. The data obtained from these <code>Realms</code> is used to verify the user’s identity to guarantee the user really is who they say they are.<ul><li><strong>Authentication Strategy</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AuthenticationStrategy.html" target="_blank" rel="noopener">org.apache.shiro.authc.pam.AuthenticationStrategy</a>)<br>If more than one <code>Realm</code> is configured, the <code>AuthenticationStrategy</code> will coordinate the Realms to determine the conditions under which an authentication attempt succeeds or fails (for example, if one realm succeeds but others fail, is the attempt successful? Must all realms succeed? Only the first?).</li></ul></li><li><strong>Authorizer</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/Authorizer.html" target="_blank" rel="noopener">org.apache.shiro.authz.Authorizer</a>)<br>The <code>Authorizer</code> is the component responsible determining users’ access control in the application. It is the mechanism that ultimately says if a user is allowed to do something or not. Like the <code>Authenticator</code>, the <code>Authorizer</code> also knows how to coordinate with multiple back-end data sources to access role and permission information. The <code>Authorizer</code> uses this information to determine exactly if a user is allowed to perform a given action.</li><li><strong>SessionManager</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/session/mgt/SessionManager.html" target="_blank" rel="noopener">org.apache.shiro.session.mgt.SessionManager</a>)<br>The <code>SessionManager</code> knows how to create and manage user <code>Session</code> lifecycles to provide a robust Session experience for users in all environments. This is a unique feature in the world of security frameworks - Shiro has the ability to natively manage user Sessions in any environment, even if there is no Web/Servlet or EJB container available. By default, Shiro will use an existing session mechanism if available, (e.g. Servlet Container), but if there isn’t one, such as in a standalone application or non-web environment, it will use its built-in enterprise session management to offer the same programming experience. The <code>SessionDAO</code> exists to allow any datasource to be used to persist sessions.<ul><li><strong>SessionDAO</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/session/mgt/eis/SessionDAO.html" target="_blank" rel="noopener">org.apache.shiro.session.mgt.eis.SessionDAO</a>)<br>The <code>SessionDAO</code> performs <code>Session</code> persistence (CRUD) operations on behalf of the <code>SessionManager</code>. This allows any data store to be plugged in to the Session Management infrastructure.</li></ul></li><li><strong>CacheManager</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/cache/CacheManager.html" target="_blank" rel="noopener">org.apache.shiro.cache.CacheManager</a>)<br>The <code>CacheManager</code> creates and manages <code>Cache</code> instance lifecycles used by other Shiro components. Because Shiro can access many back-end data sources for authentication, authorization and session management, caching has always been a first-class architectural feature in the framework to improve performance while using these data sources. Any of the modern open-source and/or enterprise caching products can be plugged in to Shiro to provide a fast and efficient user-experience.</li><li><strong>Cryptography</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/crypto/package-summary.html" target="_blank" rel="noopener">org.apache.shiro.crypto.*</a>)<br>Cryptography is a natural addition to an enterprise security framework. Shiro’s <code>crypto</code> package contains easy-to-use and understand representations of crytographic Ciphers, Hashes (aka digests) and different codec implementations. All of the classes in this package are carefully designed to be very easy to use and easy to understand. Anyone who has used Java’s native cryptography support knows it can be a challenging animal to tame. Shiro’s crypto APIs simplify the complicated Java mechanisms and make cryptography easy to use for normal mortal human beings.</li><li><strong>Realms</strong> (<a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html" target="_blank" rel="noopener">org.apache.shiro.realm.Realm</a>)<br>As mentioned above, Realms act as the ‘bridge’ or ‘connector’ between Shiro and your <strong>application’s security data</strong>. When it comes time to actually interact with security-related data like user accounts to perform authentication (login) and authorization (access control), Shiro looks up many of these things from one or more Realms configured for an application. You can configure as many <code>Realms</code> as you need (usually one per data source) and Shiro will coordinate with them as necessary for both authentication and authorization.</li></ul><h2 id="The-SecurityManager"><a href="#The-SecurityManager" class="headerlink" title="The SecurityManager"></a>The <code>SecurityManager</code></h2><p>Because Shiro’s API encourages a <code>Subject</code>-centric programming approach, most application developers will rarely, if ever, interact with the <code>SecurityManager</code> directly (framework developers however might sometimes find it useful). Even so, it is still important to know how the <code>SecurityManager</code> functions, especially when configuring one for an application.</p><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a><a href="http://shiro.apache.org/architecture.html#design" target="_blank" rel="noopener">Design</a></h3><p>As stated previously, the application’s <code>SecurityManager</code> performs security operations and manages state for <em>all</em> application users. In Shiro’s default <code>SecurityManager</code> implementations, this includes:</p><ul><li>Authentication</li><li>Authorization</li><li>Session Management</li><li>Cache Management</li><li><a href="http://shiro.apache.org/realm.html" target="_blank" rel="noopener">Realm</a> coordination</li><li>Event propagation</li><li>“Remember Me” Services</li><li>Subject creation</li><li>Logout and more.</li></ul><p>But this is a lot of functionality to try to manage in a single component. And, making these things flexible and customizable would be very difficult if everything were lumped into a single implementation class.</p><p>To simplify configuration and enable flexible configuration/pluggability, Shiro’s implementations are all highly modular in design - so modular in fact, that the SecurityManager implementation (and its class-hierarchy) does not do much at all. Instead, the <code>SecurityManager</code> implementations mostly act as a lightweight ‘container’ component, delegating almost all behavior to nested/wrapped components. This ‘wrapper’ design is reflected in the detailed architecture diagram above.</p><p>While the components actually execute the logic, the <code>SecurityManager</code> implementation knows how and when to coordinate the components for the correct behavior.</p><p>The <code>SecurityManager</code> implementations and the components are also JavaBeans compatible, which allows you (or a configuration mechanism) to easily customize the pluggable components via standard JavaBeans accessor/mutator methods (get<em>/set</em>). This means the Shiro’s architectural modularity can translate into very easy configuration for custom behavior.</p><div class="note info">            <p><strong>Easy Configuration</strong></p><p>Because of JavaBeans compatibility, it is very easy to configure the <code>SecurityManager</code> with custom components via any mechanism that supports JavaBeans-style configuration, such as <a href="http://shiro.apache.org/spring.html" target="_blank" rel="noopener">Spring</a>, Guice, JBoss, etc.</p>          </div><h2 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a><a href="http://shiro.apache.org/terminology.html#apache-shiro-terminology" target="_blank" rel="noopener">Terminology</a></h2><ul><li><strong>Authentication</strong><br>Authentication is the process of verifying a Subject’s identity - essentially proving that someone really is who they say they are. When an authentication attempt is successful the application can trust that the subject is guaranteed to be who the application expects.</li></ul><ul><li><strong>Authorization</strong><br>Authorization, also known as Access Control, is the process of determining if a user/Subject is allowed to do something or not. It is usually accomplished by inspecting and interpreting a Subject’s roles and permissions (see below) and then allowing or denying access to a requested resource or function.</li></ul><ul><li><p><strong>Cipher</strong></p><p>A cipher is an algorithm for performing encryption or decryption. The algorithm generally relies on a piece of information called a key. And the encryption varies based on the key so decyrption is extremely difficult without it.</p><p>Ciphers come in different variations. Block Ciphers work on blocks of symbols usually of a fixed size while Stream Ciphers work on a continuous stream of symbols. Symmetric Ciphers use the same key for encryption and decryption while Asymmetric Ciphers use different keys. And if a key in an asymmetric cipher cannot be derived from the other, then one can be shared publicly creating public/private key pairs.</p></li></ul><ul><li><p><strong>Credential</strong></p><p>A Credential is a piece of information that verifies the identity of a user/Subject. One (or more) credentials are submitted along with Principal(s) during an authentication attempt to verify that the user/Subject submitting them is actually the associated user. Credentials are usually very secret things that only a particular user/Subject would know, such as a password or a PGP key or biometric attribute or similar mechanism.</p><p>The idea is that for a principal, only one person would know the correct credential to ‘pair’ with that principal. If the current user/Subject provides the correct credential matching the one stored in the system, then the system can assume and trust that the current user/Subject is really who they say they are. <strong>The degree of trust increases with more secure credential types (e.g. biometric signature &gt; password).</strong></p></li></ul><ul><li><strong>Cryptography</strong><br>Cryptography is the practice of protecting information from undesired access by hiding it or converting it into nonsense so no one else can read it. Shiro focuses on two core elements of Cryptography: ciphers that encrypt data like email using a public or private key, and hashes (aka message digests) that irreversibly encrypt data like passwords.</li></ul><ul><li><strong>Hash</strong><br>A Hash function is a one-way, irreversible conversion of an input source, sometimes called the message, into an encoded hash value, sometimes called the message digest. It is often used for passwords, digital fingerprints, or data with an underlying byte array.</li></ul><ul><li><p><strong>Permission</strong></p><p>A Permission, at least as Shiro interprets it, is a statement that describes raw functionality in an application and nothing more. Permissions are the lowest-level constructs in security policies. They define only “What” the application can do. They do not describe “Who” is able to perform the actions. A Permission is only a statement of behavior, nothing more.</p><p>Some examples of permissions:</p><ul><li>Open a file</li><li>View the ‘/user/list’ web page</li><li>Print documents</li><li>Delete the ‘jsmith’ user</li></ul></li></ul><ul><li><p><strong>Principal</strong></p><p>A Principal is any identifying attribute of an application user (Subject). An ‘identifying attribute’ can be anything that makes sense to your application - a username, a surname, a given name, a social security number, a user ID, etc. That’s it - nothing crazy.</p><p>Shiro also references something we call a <code>Subject</code>’s <em>primary</em> principal. A <em>Primary</em> principal is any principal that uniquely identifies the <code>Subject</code> across the entire application. Ideal primary principals are things like a username or a user ID that is a RDBMS user table primary key. There is only one primary principal for users (Subjects) in an application.</p></li></ul><ul><li><p><strong>Realm</strong></p><p>A Realm is a component that can access application-specific security data such as users, roles, and permissions. It can be thought of as a security-specific DAO (Data Access Object). The Realm translates this application-specific data into a format that Shiro understands so Shiro can in turn provide a single easy-to-understand Subject programming API no matter how many data sources exist or how application-specific your data might be.</p><p>Realms usually have a 1-to-1 correlation with a data source such as a relational database, LDAP directory, file system, or other similar resource. As such, implementations of the Realm interface use data source-specific APIs to discover authorization data (roles, permissions, etc), such as JDBC, File IO, Hibernate or JPA, or any other Data Access API.</p></li></ul><ul><li><p><strong>Role</strong></p><p>The definition of a Role can vary based on who you talk to. In many applications it is a nebulous concept at best that people use to implicitly define security policies. Shiro prefers to interpret a Role as simply a named collection of Permissions. That’s it - an application unique name aggregating one or more Permission declarations.</p><p>This is a more concrete definition than the implicit one used by many applications. If you choose to have your data model reflect Shiro’s assumption, you’ll find you will have much more power in controlling security policies.</p></li></ul><ul><li><p><strong>Session</strong></p><p>A Session is a stateful data context associated with a single user/Subject who interacts with a software system over a period of time. Data can be added/read/removed from the Session while the subject uses the application and the application can use this data later where necessary. Sessions are terminated when the user/Subject logs out of the application or when it times out due to inactivity.</p><p>For those familiar with the HttpSession, a Shiro <code>Session</code> serves the same purpose, except Shiro sessions can be used in any environment even if there is no Servlet container or EJB container available.</p></li></ul><ul><li><strong>Subject</strong><br>A <em>Subject</em> is just fancy security term that basically means a security-specific ‘view’ of an application user. A Subject does not always need to reflect a human being though - it can represent an external process calling your application, or perhaps a daemon system account that executes something intermittently over a period of time (such as a cron job). It is basically a representation of any entity that is doing something with the application.</li></ul><h1 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h1><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a><a href="http://shiro.apache.org/authentication.html#apache-shiro-authentication" target="_blank" rel="noopener">Authentication</a></h2><h3 id="Authenticating-Subjects"><a href="#Authenticating-Subjects" class="headerlink" title="Authenticating Subjects"></a>Authenticating Subjects</h3><ol><li><p>Collect the Subject’s principals and credentials</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example using most common scenario of username/password pair: </span></span><br><span class="line">UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line"><span class="comment">//"Remember Me" built-in:  </span></span><br><span class="line">token.setRememberMe(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li><li><p>Submit the principals and credentials</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">currentUser.login(token);</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>Handling Success or Failure</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125; <span class="keyword">catch</span> ( UnknownAccountException uae ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( IncorrectCredentialsException ice ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( LockedAccountException lae ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( ExcessiveAttemptsException eae ) &#123; ...</span><br><span class="line">&#125; ... <span class="keyword">catch</span> your own ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( AuthenticationException ae ) &#123;</span><br><span class="line">    <span class="comment">//unexpected error?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//No problems, continue on as expected...</span></span><br></pre></td></tr></table></figure><h3 id="Remembered-vs-Authenticated"><a href="#Remembered-vs-Authenticated" class="headerlink" title="Remembered vs. Authenticated"></a>Remembered vs. Authenticated</h3><div class="note warning">            <p><strong>Mutually Exclusive</strong></p><p>Remembered and authenticated states are mutually exclusive - a <code>true</code> value for one indicates a <code>false</code> value for the other and vice versa.</p><p>Remembered记住的是登录人信息，但是实际操作人不一定是本人，所以当涉及敏感信息时，还是推荐Authenticated重新认证</p>          </div><h3 id="Logging-Out"><a href="#Logging-Out" class="headerlink" title="Logging Out"></a><a href="http://shiro.apache.org/authentication.html#logging-out" target="_blank" rel="noopener">Logging Out</a></h3><p>The opposite of authenticating is releasing all known identifying state. When the <code>Subject</code> is done interacting with the application, you can call <code>subject.</code><a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/subject/Subject.html#logout--" target="_blank" rel="noopener"><code>logout()</code></a> to relinquish all identifying information:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentUser.logout(); &#x2F;&#x2F;removes all identifying information and invalidates their session too.</span><br></pre></td></tr></table></figure><p>When you call <code>logout</code>, any existing <code>Session</code> will be invalidated and any identity will be disassociated (e.g. in a web app, the RememberMe cookie will also be deleted).</p><p>After a <code>Subject</code> logs-out, the <code>Subject</code> instance is considered anonymous again and, except for web applications, can be re-used for <code>login</code> again if desired.</p><div class="note danger">            <p> <strong>Web Application Notice</strong></p><p>Because remembered identity in web applications is often persisted with cookies, and cookies can only be deleted before a Response body is committed, it is highly recommended to redirect the end-user to a new view or page immediately after calling <code>subject.logout()</code>.</p>          </div><h2 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a><a href="http://shiro.apache.org/authorization.html#apache-shiro-authorization" target="_blank" rel="noopener">Authorization</a></h2><blockquote><p>授权是基于resources(door, file, customer, etc)和actions的 (open, read, delete, etc)</p></blockquote><div class="tabs" id="unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#unique-name-1">编程式授权</a></li><li class="tab"><a href="#unique-name-2">注解式授权</a></li></ul><div class="tab-content"><div class="tab-pane active" id="unique-name-1"><p> 方法check会返回boolean，assertion会静默执行逻辑或抛出异常</p><ol><li>基于角色，简单直观</li><li>基于权限，粒度更细，安全策略变化时，对源码的影响更小<ul><li>基于object的，类型安全但略微笨重</li><li>基于string（<a href="http://shiro.apache.org/permissions.html#wildcard-permissions" target="_blank" rel="noopener">Wildcard Permissions</a>）的，简单易读，但类型不安全</li></ul></li></ol></div><div class="tab-pane" id="unique-name-2"><p>需要先开启AOP支持</p><ol><li><p><code>RequiresAuthentication</code> </p></li><li><p><code>RequiresGuest</code> </p></li><li><p><code>RequiresPermissions</code> </p></li><li><p><code>RequiresRoles</code></p></li><li><p><code>RequiresUser</code> </p></li></ol></div></div></div><h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a><a href="http://shiro.apache.org/realm.html" target="_blank" rel="noopener">Realm</a></h2><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a><a href="http://shiro.apache.org/session-management.html#session-management" target="_blank" rel="noopener">Session</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;&lt;strong&gt;Apache Shiro™&lt;/strong&gt; is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.&lt;/p&gt;&lt;p&gt;Welcome to &lt;a href=&quot;http://shiro.apache.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Shiro!&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="框架" scheme="https://zystrivego.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="auth" scheme="https://zystrivego.github.io/tags/auth/"/>
    
  </entry>
  
  <entry>
    <title>键盘折腾史</title>
    <link href="https://zystrivego.github.io/2020/05/22/%E9%94%AE%E7%9B%98%E6%8A%98%E8%85%BE%E5%8F%B2/"/>
    <id>https://zystrivego.github.io/2020/05/22/%E9%94%AE%E7%9B%98%E6%8A%98%E8%85%BE%E5%8F%B2/</id>
    <published>2020-05-21T17:54:26.000Z</published>
    <updated>2020-11-02T18:31:05.431Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/05/22/%E9%94%AE%E7%9B%98%E6%8A%98%E8%85%BE%E5%8F%B2/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200522022330.jpg" class=""><blockquote><p>为了手腕着想，键盘厚度超过20mm就要考虑配掌托了，不想折腾的推荐ThinkPad小红点键盘。</p></blockquote><a id="more"></a><h1 id="IKBC-C104"><a href="#IKBC-C104" class="headerlink" title="IKBC C104"></a>IKBC C104</h1><p>初入机械键盘的坑，本着不折腾，一把就退烧的想法买了红轴，确实和薄膜不一样，但也没有很惊艳，最后搬家前闲鱼出手。</p><h1 id="IKBC-E412"><a href="#IKBC-E412" class="headerlink" title="IKBC E412"></a>IKBC E412</h1><p>又是红轴，这一款是带掌托的，用了一年左右，总感觉键盘太大，使用鼠标手肘移动距离过长，半价出给了同事。</p><h1 id="罗技K580"><a href="#罗技K580" class="headerlink" title="罗技K580"></a>罗技K580</h1><blockquote><p>对于不确实会长期持有的东西最好在闲鱼买，最后出掉也不会亏多少，甚至还有赚的可能</p></blockquote><p>闲鱼入了把K580，作为无线键盘很好，长续航，重量轻，罗技黑科技也都有：优联很好，蓝牙切换也很快，flow功能很鸡肋，因为延迟很大。键盘手感很差，还不如我的笔记本键盘，最后闲鱼出掉。</p><h1 id="NIZ68"><a href="#NIZ68" class="headerlink" title="NIZ68"></a>NIZ68</h1><p>宁芝静电容68双模，网上都说静电容退烧，我信了，买回来晚上同事敲了下，他说80块都不要，而我800买的，静电容确实很小众，键盘手感特别软，感觉键帽下面是空心一样，而且这款退格键设计的有问题，不容易够到，故第二天退掉。</p><h1 id="小红点USB键盘"><a href="#小红点USB键盘" class="headerlink" title="小红点USB键盘"></a>小红点USB键盘</h1><p>ThinkPad的键盘网上口碑很好，而且公司发的联想昭阳k22-80的键盘就是类ThinkPad的，打字很舒服，就在闲鱼上买了一把，卖家很好心，知道我是武汉的还退了10块给我。</p><p>键盘布局非常好，打字很流畅长时间也不吃力，由于不到10mm的厚度，也不需要掌托。感觉ThinkPad的老用户有很多守旧的人不喜欢巧克力设计，可能是我先入为主，我是很喜欢的，美观而且厚度薄对手腕友好，这把键盘应该会长期持有。</p><p>槽点：Fn和CTRL的位置是反的，不过慢慢也习惯了，开始觉得小红点不实用，用了一个月后觉得真香。</p><p>期待：二代无线小红点键盘<a href="https://www.lenovo.com/us/en/accessories-and-monitors/new-arrivals/KBD-BO-TrackPoint-KBD-US-Eng/p/4Y40X49493" target="_blank" rel="noopener">ThinkPad TrackPoint Keyboard II</a></p><h1 id="黑爵K680T"><a href="#黑爵K680T" class="headerlink" title="黑爵K680T"></a>黑爵K680T</h1><p>体验了把青轴，不是我的菜，那把白色的就是，布局还是很好的</p><img src="/2020/05/22/%E9%94%AE%E7%9B%98%E6%8A%98%E8%85%BE%E5%8F%B2/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200522022316.jpg" class=""><h1 id="京东京造-K1-87"><a href="#京东京造-K1-87" class="headerlink" title="京东京造 K1/87"></a>京东京造 K1/87</h1><img src="/2020/05/22/%E9%94%AE%E7%9B%98%E6%8A%98%E8%85%BE%E5%8F%B2/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200522031118.jpg" class=""><img src="/2020/05/22/%E9%94%AE%E7%9B%98%E6%8A%98%E8%85%BE%E5%8F%B2/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200522022334.jpg" class=""><div class="note info">            <p>佳达隆定制矮红轴，对应产品 <a href="https://www.keychron.com/products/keychron-k1-wireless-mechanical-keyboard" target="_blank" rel="noopener">keychron k1 v3</a>  </p><p>主输入区非常静音，手感红轴偏薄膜吧，触发很迅速，大键都是用的平衡杆，触感声响各异，可玩性不错，但还是要配掌托，且个人感觉长时间输入还是不如小红点键盘舒服。</p><img src="/2020/05/22/%E9%94%AE%E7%9B%98%E6%8A%98%E8%85%BE%E5%8F%B2/k1gateron.png" class="">          </div><h1 id="GS87D"><a href="#GS87D" class="headerlink" title="GS87D"></a>GS87D</h1><div class="note info">            <p>蓝牙5.0有线双模，TypeC键线分离，干电池，热升华键帽，87键cherry红轴，339，配置很残暴，但做工确实一般，大键晃动严重，手感没有上面那把好，而且键盘太高。立个flag，除非机械键盘做到薄膜键盘一样的高度，否则不再折腾机械键盘。</p><img src="/2020/05/22/%E9%94%AE%E7%9B%98%E6%8A%98%E8%85%BE%E5%8F%B2/gs87d.jpg" class="">          </div><h1 id="Keychron-K1v4"><a href="#Keychron-K1v4" class="headerlink" title="Keychron K1v4"></a>Keychron K1v4</h1><div class="note info">            <p>这款手托不好找，11mm的黑爵塑料手托是我能找到的最合适的了，目前长时间输入也不累，触发压力要比上一代大，不知道是不是换了曲面键帽的缘故，背光开着比较美观，关闭情况下相当于一把无刻键盘<br><img src="https://gitee.com/zystrivego/misc/raw/master/k1v4%20palm%20rest.jpg" alt="k1v4 palm rest"></p><p><img src="https://gitee.com/zystrivego/misc/raw/master/k1v4%20quick%20start.jpg" alt="k1v4 quick start"></p>          </div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/05/22/%E9%94%AE%E7%9B%98%E6%8A%98%E8%85%BE%E5%8F%B2/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200522022330.jpg&quot; class=&quot;&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;为了手腕着想，键盘厚度超过20mm就要考虑配掌托了，不想折腾的推荐ThinkPad小红点键盘。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="外设" scheme="https://zystrivego.github.io/categories/%E5%A4%96%E8%AE%BE/"/>
    
    
      <category term="键盘" scheme="https://zystrivego.github.io/tags/%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://zystrivego.github.io/2020/05/20/Maven/"/>
    <id>https://zystrivego.github.io/2020/05/20/Maven/</id>
    <published>2020-05-20T08:44:15.000Z</published>
    <updated>2020-09-07T18:07:52.595Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of information.</p></blockquote><a id="more"></a><h1 id="镜像和库"><a href="#镜像和库" class="headerlink" title="镜像和库"></a>镜像和库</h1><h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><h3 id="Maven仓库理解和优先级"><a href="#Maven仓库理解和优先级" class="headerlink" title="Maven仓库理解和优先级"></a><a href="https://swenfang.github.io/2018/06/03/Maven-Priority/" target="_blank" rel="noopener">Maven仓库理解和优先级</a></h3><h3 id="Settings-Reference"><a href="#Settings-Reference" class="headerlink" title="Settings Reference"></a><a href="http://maven.apache.org/settings.html" target="_blank" rel="noopener">Settings Reference</a></h3><h3 id="POM-Reference"><a href="#POM-Reference" class="headerlink" title="POM Reference"></a><a href="http://maven.apache.org/pom.html" target="_blank" rel="noopener">POM Reference</a></h3><h3 id="Using-Mirrors-for-Repositories"><a href="#Using-Mirrors-for-Repositories" class="headerlink" title="Using Mirrors for Repositories"></a><a href="http://maven.apache.org/guides/mini/guide-mirror-settings.html" target="_blank" rel="noopener">Using Mirrors for Repositories</a></h3><h3 id="Introduction-to-Repositories"><a href="#Introduction-to-Repositories" class="headerlink" title="Introduction to Repositories"></a><a href="http://maven.apache.org/guides/introduction/introduction-to-repositories.html" target="_blank" rel="noopener">Introduction to Repositories</a></h3><h3 id="Repository-Manager"><a href="#Repository-Manager" class="headerlink" title="Repository Manager"></a><a href="http://maven.apache.org/repository-management.html" target="_blank" rel="noopener">Repository Manager</a></h3><h2 id="使用镜像的理由"><a href="#使用镜像的理由" class="headerlink" title="使用镜像的理由"></a>使用镜像的理由</h2><ol><li>加速拉取</li><li>使用自己的库</li><li>私服需要</li></ol><h2 id="mirrorOf的使用"><a href="#mirrorOf的使用" class="headerlink" title="mirrorOf的使用"></a>mirrorOf的使用</h2><blockquote><p>镜像是为一个或一组特定的仓库服务的</p></blockquote><p>Examples:</p><ul><li><code>*</code> = everything</li><li><code>external:*</code> = everything not on the localhost and not file based.</li><li><code>repo,repo1</code> = repo or repo1</li><li><code>*,!repo1</code> = everything except repo1</li></ul><p><code>*</code>号一般是公司私服仓库组使用比较好，如果配置多个镜像，maven会先精确匹配，再根据通配符匹配优先声明的</p><h2 id="repository的使用"><a href="#repository的使用" class="headerlink" title="repository的使用"></a>repository的使用</h2><blockquote><p>maven 仓库的优先级：本地仓库 &gt; 私服（profile）&gt; 远程仓库（repository）</p></blockquote><ol><li><p>当项目声明一个本地存储库中不存在的依赖项(或者对于 SNAPSHOT，当远程存储库包含一个更新的存储库时)，远程下载就会被触发， 默认情况下，Maven 将从中央存储库下载。</p></li><li><p>个性化的库最好在项目里的pom.xml里指定。</p></li></ol><h2 id="公共代理库（镜像）"><a href="#公共代理库（镜像）" class="headerlink" title="公共代理库（镜像）"></a>公共代理库（镜像）</h2><h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a><a href="https://help.aliyun.com/document_detail/102512.html" target="_blank" rel="noopener">阿里云</a></h3><h2 id="maven手动安装jar包"><a href="#maven手动安装jar包" class="headerlink" title="maven手动安装jar包"></a>maven手动安装jar包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -DgroupId= -DartifactId= -Dversion= -Dpackaging=jar -Dfile=</span><br></pre></td></tr></table></figure><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="assembly"><a href="#assembly" class="headerlink" title="assembly"></a><a href="http://maven.apache.org/plugins/maven-assembly-plugin/usage.html" target="_blank" rel="noopener">assembly</a></h2><p>自定义打包的范围，常见于一个运行主模块带其它依赖模块一起打包，方便部署</p><h3 id="基本配置："><a href="#基本配置：" class="headerlink" title="基本配置："></a>基本配置：</h3><p>其中descriptorRef是关键，可自行配置，它决定了如何装配你的程序集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">  [...]</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    [...]</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-assembly-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;descriptorRefs&gt;</span><br><span class="line">            &lt;descriptorRef&gt;jar-with-dependencies&lt;&#x2F;descriptorRef&gt;</span><br><span class="line">          &lt;&#x2F;descriptorRefs&gt;</span><br><span class="line">        &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;executions&gt;</span><br><span class="line">          &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;make-assembly&lt;&#x2F;id&gt; &lt;!-- this is used for inheritance merges --&gt;</span><br><span class="line">            &lt;phase&gt;package&lt;&#x2F;phase&gt; &lt;!-- bind to the packaging phase --&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">              &lt;goal&gt;single&lt;&#x2F;goal&gt;</span><br><span class="line">            &lt;&#x2F;goals&gt;</span><br><span class="line">          &lt;&#x2F;execution&gt;</span><br><span class="line">        &lt;&#x2F;executions&gt;</span><br><span class="line">      &lt;&#x2F;plugin&gt;</span><br><span class="line">      [...]</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><h3 id="Creating-an-Executable-JAR"><a href="#Creating-an-Executable-JAR" class="headerlink" title="Creating an Executable JAR"></a>Creating an Executable JAR</h3><p>会生成入口文件：META-INF/MANIFEST.MF；</p><p>仅仅jar和war支持archive元素；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">  [...]</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    [...]</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-assembly-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          [...]</span><br><span class="line">          &lt;archive&gt;</span><br><span class="line">            &lt;manifest&gt;</span><br><span class="line">              &lt;mainClass&gt;org.sample.App&lt;&#x2F;mainClass&gt;</span><br><span class="line">            &lt;&#x2F;manifest&gt;</span><br><span class="line">          &lt;&#x2F;archive&gt;</span><br><span class="line">        &lt;&#x2F;configuration&gt;</span><br><span class="line">        [...]</span><br><span class="line">      &lt;&#x2F;plugin&gt;</span><br><span class="line">      [...]</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of information.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://zystrivego.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="maven" scheme="https://zystrivego.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo和NexT的博客搭建</title>
    <link href="https://zystrivego.github.io/2020/05/13/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CNexT%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://zystrivego.github.io/2020/05/13/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CNexT%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-05-13T09:57:34.000Z</published>
    <updated>2020-09-20T15:34:56.192Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <p>主要记录一些要注意的点，因为网上教程版本众多，所以尽量以最新的官方文档为准。</p>            <i class="fa fa-quote-right"></i>          </blockquote><a id="more"></a><h1 id="官方文档地址"><a href="#官方文档地址" class="headerlink" title="官方文档地址"></a>官方文档地址</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo官网</a></p><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT中文文档</a></p><p><a href="https://theme-next.js.org/docs/" target="_blank" rel="noopener">NexT英文文档</a></p><h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul><li><p>Node.js <a href="https://nodejs.org/en/" target="_blank" rel="noopener">v12.16.3</a></p></li><li><p>hexo: <a href="https://github.com/hexojs/hexo/tree/4.2.1" target="_blank" rel="noopener">4.2.1</a></p></li><li><p>NexT: <a href="https://github.com/next-theme/hexo-theme-next/releases/tag/v8.0.0-rc.2" target="_blank" rel="noopener">v8.0.0-rc.2</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2014-2017https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next</span><br><span class="line">2018-2019https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next</span><br><span class="line">2020    https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-theme-next</span><br></pre></td></tr></table></figure></li></ul><h1 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h1><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013&#x2F;7&#x2F;13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章网址</td><td align="left"></td></tr><tr><td align="left"><code>keywords</code></td><td align="left">仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td><td align="left"></td></tr></tbody></table><h2 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h2><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure><blockquote><p>分类方法的分歧</p><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure><p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p></blockquote><h1 id="搭建要点"><a href="#搭建要点" class="headerlink" title="搭建要点"></a>搭建要点</h1><p>在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。</p><p>其实主要就是修改这两个文件，有的会需要结合修改部分的描述安装你需要的功能插件。</p><h2 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h2><p>设置分类和标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>分别在Front-matter中设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: &quot;categories&quot;</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure><h2 id="5款插件"><a href="#5款插件" class="headerlink" title="5款插件"></a>5款插件</h2><blockquote><p> <strong>前4款在站点根目录下安装，后1款在主题根目录下安装</strong></p></blockquote><h3 id="生成RSS"><a href="#生成RSS" class="headerlink" title="生成RSS"></a>生成RSS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure><p>修改<strong>主题配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">RSS:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure><h3 id="文章pinned"><a href="#文章pinned" class="headerlink" title="文章pinned"></a>文章pinned</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">uninstall</span> <span class="string">hexo-generator-index</span> <span class="string">--save</span></span><br><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-index-pin-top</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure><p>需要pinned的文章在 <strong>Front-matter</strong> 中加上 <strong>top</strong> 即可，数值越大表示等级越高，越靠前显示</p><p>显示效果需要修改themes\hexo-theme-next\layout_macro\post.njk，在<code>&lt;header class=&quot;post-header&quot;&gt;</code>（我这里是第18行）下插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">    &lt;i class&#x3D;&quot;fa fa-thumbtack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索插件"><a href="#搜索插件" class="headerlink" title="搜索插件"></a>搜索插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>编辑 <strong>站点配置文件</strong>，新增以下内容到任意位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>编辑 <strong>主题配置文件</strong>，启用本地搜索功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="部署插件"><a href="#部署插件" class="headerlink" title="部署插件"></a>部署插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>编辑 <strong>站点配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: 你的gitee或github库</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="页面加载进度条"><a href="#页面加载进度条" class="headerlink" title="页面加载进度条"></a>页面加载进度条</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-pace source&#x2F;lib&#x2F;pace</span><br></pre></td></tr></table></figure><p>修改<strong>主题配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pace:</span><br><span class="line"> enable: true</span><br></pre></td></tr></table></figure><h2 id="其它的一些功能"><a href="#其它的一些功能" class="headerlink" title="其它的一些功能"></a>其它的一些功能</h2><p>大部分修改下<strong>主题配置文件</strong>就行了</p><p>下面是修改的部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"> 这个是突出页脚红心的</span><br><span class="line">   # Icon between year and copyright info.</span><br><span class="line">   icon:</span><br><span class="line">     # Icon name in Font Awesome. See: https:&#x2F;&#x2F;fontawesome.com&#x2F;icons</span><br><span class="line">-    name: fa fa-heart</span><br><span class="line">+    name: fa fa-heartbeat</span><br><span class="line">     # If you want to animate the icon, set it to true.</span><br><span class="line">-    animated: false</span><br><span class="line">+    animated: true</span><br><span class="line">     # Change the color of icon, using Hex Code.</span><br><span class="line">     color: &quot;#ff0000&quot;</span><br><span class="line"> </span><br><span class="line">这个是侧栏显示许可证</span><br><span class="line"> # CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https:&#x2F;&#x2F;creativecommons.org</span><br><span class="line"> creative_commons:</span><br><span class="line">   license: by-nc-sa</span><br><span class="line">-  sidebar: false</span><br><span class="line">+  sidebar: true</span><br><span class="line">   post: false</span><br><span class="line">   language:</span><br><span class="line"> </span><br><span class="line">这个是主题风格修改</span><br><span class="line"> # Schemes</span><br><span class="line">-scheme: Muse</span><br><span class="line">+#scheme: Muse</span><br><span class="line"> #scheme: Mist</span><br><span class="line"> #scheme: Pisces</span><br><span class="line">-#scheme: Gemini</span><br><span class="line">+scheme: Gemini</span><br><span class="line"> </span><br><span class="line">这个是菜单栏修改</span><br><span class="line"> menu:</span><br><span class="line">-  #home: &#x2F; || fa fa-home</span><br><span class="line">+  home: &#x2F; || fa fa-home</span><br><span class="line">   #about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">-  #tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">-  #categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">-  #archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">+  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">+  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">+  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">   #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">   #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">   #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br><span class="line"></span><br><span class="line">这个是头像设置</span><br><span class="line"> # Sidebar Avatar</span><br><span class="line"> avatar:</span><br><span class="line">   # Replace the default image and set the url here.</span><br><span class="line">-  url: #&#x2F;images&#x2F;avatar.gif</span><br><span class="line">+  url: &#x2F;images&#x2F;王也.jpg</span><br><span class="line">   # If true, the avatar will be dispalyed in circle.</span><br><span class="line">   rounded: false</span><br><span class="line">   # If true, the avatar will be rotated with the cursor.</span><br><span class="line"></span><br><span class="line">这个是代码块复制按钮设置</span><br><span class="line">   # Add copy button on codeblock</span><br><span class="line">   copy_button:</span><br><span class="line">-    enable: false</span><br><span class="line">+    enable: true</span><br><span class="line"></span><br><span class="line">这个是滚动百分比设置</span><br><span class="line">   # Scroll percent label in b2t button.</span><br><span class="line">-  scrollpercent: false</span><br><span class="line">+  scrollpercent: true</span><br><span class="line"> </span><br><span class="line"> # Reading progress bar</span><br><span class="line"> reading_progress:</span><br><span class="line">@@ -472,7 +475,7 @@</span><br><span class="line"> baidu_site_verification:</span><br><span class="line"> </span><br><span class="line"> 百度推送，搜索引擎优化</span><br><span class="line"> # Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO.</span><br><span class="line">-baidu_push: false</span><br><span class="line">+baidu_push: true</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">这个是评论系统，适合国内使用</span><br><span class="line"> # Valine</span><br><span class="line"> # For more information: https:&#x2F;&#x2F;valine.js.org, https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine</span><br><span class="line"> valine:</span><br><span class="line">-  enable: false</span><br><span class="line">-  appId: # Your leancloud application appid</span><br><span class="line">-  appKey: # Your leancloud application appkey</span><br><span class="line">+  enable: true</span><br><span class="line">+  appId: xxxxxx</span><br><span class="line">+  appKey: xxxxxxx</span><br><span class="line">-  placeholder: Just go go # Comment box placeholder</span><br><span class="line">+  placeholder: 无需注册，支持Markdown格式 # Comment box placeholder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">搜索引擎优化</span><br><span class="line"> # Google Analytics</span><br><span class="line"> google_analytics:</span><br><span class="line">-  tracking_id: # &lt;app_id&gt;</span><br><span class="line">+  tracking_id: xxxxxx</span><br><span class="line"></span><br><span class="line">搜索引擎优化</span><br><span class="line"> # Baidu Analytics</span><br><span class="line">-baidu_analytics: # &lt;app_id&gt;</span><br><span class="line">+baidu_analytics: xxxxxx</span><br></pre></td></tr></table></figure><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>修改 <strong>站点配置文件</strong></p><p>开启<strong>文章资源文件夹</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>使用Hexo内置标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img slug [title] %&#125;</span><br></pre></td></tr></table></figure><h3 id="如何设置「阅读全文」"><a href="#如何设置「阅读全文」" class="headerlink" title="如何设置「阅读全文」"></a>如何设置「阅读全文」</h3><p>在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供2种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 <strong>阅读全文</strong> 按钮，可以通过以下方法：</p><ol><li>在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，Hexo 提供的方式 <strong>推荐</strong></li><li>在文章的 <a href="https://hexo.io/docs/front-matter.html" target="_blank" rel="noopener">front-matter</a> 中添加 <code>description</code>，并提供文章摘录</li></ol><blockquote><p>建议使用 <code>&lt;!-- more --&gt;</code>（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。</p></blockquote><h3 id="渲染跳过"><a href="#渲染跳过" class="headerlink" title="渲染跳过"></a>渲染跳过</h3><p>比如404，README文件</p><p>修改<strong>站点配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">  - README.md</span><br><span class="line">  - 404.html</span><br></pre></td></tr></table></figure><h3 id="开源协议怎么选"><a href="#开源协议怎么选" class="headerlink" title="开源协议怎么选"></a>开源协议怎么选</h3><p><a href="https://creativecommons.org/use-remix/cc-licenses/" target="_blank" rel="noopener">Creative Commons Licenses</a></p><p><a href="https://choosealicense.com/" target="_blank" rel="noopener">Choose an open source license</a></p><h3 id="小图标在哪找"><a href="#小图标在哪找" class="headerlink" title="小图标在哪找"></a>小图标在哪找</h3><p>font-awesome:<code>themes\hexo-theme-next\source\lib\font-awesome\css\all.min.css</code></p><p><a href="https://www.iconfont.cn/home/index" target="_blank" rel="noopener">Iconfont-阿里巴巴矢量图标库</a></p><h3 id="增加阿里巴巴矢量图标库"><a href="#增加阿里巴巴矢量图标库" class="headerlink" title="增加阿里巴巴矢量图标库"></a>增加阿里巴巴矢量图标库</h3><p><a href="https://blog.dlzhang.com/posts/32/" target="_blank" rel="noopener">参考地址</a></p><p>站点根目录下添加source\ _data\styles.styl，把iconfont.css文件内容全拷过去即可。</p><p>编辑 <strong>主题配置文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> custom_file_path:</span><br><span class="line">-  #style: source&#x2F;_data&#x2F;styles.styl</span><br><span class="line">+  style: source&#x2F;_data&#x2F;styles.styl</span><br><span class="line"></span><br><span class="line">这个是侧栏社交链接和图标设置</span><br><span class="line"> social:</span><br><span class="line">-  #GitHub: https:&#x2F;&#x2F;github.com&#x2F;yourname || fab fa-github</span><br><span class="line">-  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">+  码云: https:&#x2F;&#x2F;gitee.com&#x2F;zystrivego&#x2F;blog || fab iconfont icon-Ggooglelogo</span><br><span class="line">+  邮箱: mailto:zystrivego@163.com || fa iconfont icon-youxiang</span><br><span class="line">+  音乐: http:&#x2F;&#x2F;music.163.com&#x2F;m&#x2F;user&#x2F;home?id&#x3D;15370305 || fa iconfont icon-netease-cloud-music-line</span><br></pre></td></tr></table></figure><h3 id="评论邮件通知"><a href="#评论邮件通知" class="headerlink" title="评论邮件通知"></a>评论邮件通知</h3><p>参考地址：<a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a></p><h1 id="官方文档摘录"><a href="#官方文档摘录" class="headerlink" title="官方文档摘录"></a>官方文档摘录</h1><h2 id="不要处理我的文章"><a href="#不要处理我的文章" class="headerlink" title="不要处理我的文章"></a>不要处理我的文章</h2><p>如果你不想你的文章被处理，你可以将 Front-Matter 中的<code>layout:</code> 设为 <code>false</code> 。</p><h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><h2 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h2><p>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p><h3 id="文章资源文件夹"><a href="#文章资源文件夹" class="headerlink" title="文章资源文件夹"></a>文章资源文件夹</h3><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_config.ymlpost_asset_folder: true</span><br></pre></td></tr></table></figure><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout]</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><h3 id="相对路径引用的标签插件"><a href="#相对路径引用的标签插件" class="headerlink" title="相对路径引用的标签插件"></a>相对路径引用的标签插件</h3><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](/example.jpg)</code> ，它将 <em>不会</em> 出现在首页上。（但是它会在文章中按你期待的方式工作）</p><p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg [This is an example image] %&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>发表草稿。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration" target="_blank" rel="noopener">迁移内容</a>。</p><p>###clean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure><p>列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new" target="_blank" rel="noopener">提交调试信息到 GitHub</a>。</p><h4 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure><p>隐藏终端信息。</p><h4 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h4 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd</span><br></pre></td></tr></table></figure><p>自定义当前工作目录（Current working directory）的路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;
            &lt;i class=&quot;fa fa-quote-left&quot;&gt;&lt;/i&gt;
            &lt;p&gt;主要记录一些要注意的点，因为网上教程版本众多，所以尽量以最新的官方文档为准。&lt;/p&gt;

            &lt;i class=&quot;fa fa-quote-right&quot;&gt;&lt;/i&gt;
          &lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="misc" scheme="https://zystrivego.github.io/categories/misc/"/>
    
    
      <category term="Hexo" scheme="https://zystrivego.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="https://zystrivego.github.io/tags/NexT/"/>
    
  </entry>
  
</feed>
